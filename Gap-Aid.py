#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import pyfastx,re
import sys
import os
import subprocess
import shutil
import time
import json
import pickle
import random
from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit, QMenu, QTreeWidgetItem, QAction, QMessageBox, QVBoxLayout, QScrollArea, QTableWidgetItem, QTableWidget, QAbstractItemView, QHeaderView, QScrollBar, QToolTip, QWidget, QFileDialog
from PyQt5.QtCore import Qt, QEventLoop, QPoint, pyqtSignal, QSize, QEvent, QRect, QRectF, QCoreApplication
from PyQt5.QtGui import QIcon, QCursor, QPixmap, QFont
import numpy as np
import pyqtgraph as pg
from PyQt5.QtSvg import QSvgWidget, QSvgGenerator
from functools import partial
import traceback
from qfluentwidgets import PushButton, StrongBodyLabel, TeachingTipView, TeachingTip, InfoBarIcon, InfoBar, InfoBarPosition, StateToolTip
from qfluentwidgets import FluentIcon as FIF
import warnings
warnings.filterwarnings("ignore")
svgwidth = 0
svghight = 0


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.resize(1523, 810)
        MainWindow.setWindowTitle("Gap-Aid")
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        icon = QIcon(fr'{self.script_dir}/source/LOGO.png')
        MainWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.msgbox = QtWidgets.QMessageBox()
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.folder_icon = QIcon()
        self.folder_icon.addPixmap(QPixmap(f"{self.script_dir}/source/folder.png"))
        self.help_icon = QIcon()
        self.help_icon.addPixmap(QPixmap(f"{self.script_dir}/source/help.png"))
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit = QLineEdit()
        self.lineEdit.setStyleSheet(
            '''QLineEdit{border-radius:5px;font-size:10pt;font-family:"Arial";border: 1px solid #A0A0A0;color:#959595;height:25px;background-color: rgb(255, 255, 255);}''')
        self.horizontalLayout.addWidget(self.lineEdit)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setFlat(True)
        self.pushButton_2.setToolTip("open the genome sequence file")
        self.pushButton_2.setIcon(self.folder_icon)
        self.pushButton_2.clicked.connect(self.open_direction)
        self.horizontalLayout.addWidget(self.pushButton_2)
        self.lineEdit_3 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_3.setPlaceholderText('Telomere monomer sequence (e.g., TTTAGGG)')
        self.lineEdit_3.setStyleSheet(
            '''QLineEdit{border-radius:5px;font-size:10pt;font-family:"Arial";border: 1px solid #A0A0A0;height:25px;background-color: rgb(255, 255, 255);}''')
        self.lineEdit_3.returnPressed.connect(self.search_telomere)
        self.horizontalLayout.addWidget(self.lineEdit_3)
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setFlat(True)
        self.pushButton_3.setToolTip("help")
        self.pushButton_3.setIcon(self.help_icon)
        # self.pushButton_3.clicked.connect(self.open_direction)
        self.horizontalLayout.addWidget(self.pushButton_3)

        self.horizontalLayout.setStretch(0, 3)
        self.horizontalLayout.setStretch(2, 1)
        self.horizontalLayout_5.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout_5.addLayout(self.horizontalLayout_2)
        self.verticalLayout_3.addLayout(self.horizontalLayout_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.horizontalLayout_6.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.horizontalLayout_6.addLayout(self.horizontalLayout_4)
        self.verticalLayout_3.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.addItem('Chr IDs')
        self.comboBox.setStyleSheet('''QComboBox{font-family: "Arial"}''')
        self.comboBox.currentIndexChanged.connect(self.selectionchange)
        self.horizontalLayout_7.addWidget(self.comboBox)
        self.comboBox_2 = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox_2.addItem("gap positions")
        self.comboBox_2.setStyleSheet(
            '''QComboBox{font-family: "Arial";color:#FF0000}''')
        self.comboBox_2.currentIndexChanged.connect(self.show_potentials)
        self.horizontalLayout_7.addWidget(self.comboBox_2)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setStyleSheet(
            '''QLineEdit{border-radius:5px;font-size:10pt;font-family:"Arial";border: 1px solid #A0A0A0;color:#FF0000;height:25px;background-color: rgb(255, 255, 255);}''')
        self.horizontalLayout_7.addWidget(self.lineEdit_2)
        # self.lineEdit_3 = QtWidgets.QLineEdit(self.centralwidget)
        # self.lineEdit_3.setPlaceholderText('Telomere monomer sequence (e.g., TTTAGGG)')
        # self.lineEdit_3.setStyleSheet(
        #     '''QLineEdit{border-radius:5px;font-size:10pt;font-family:"Arial";border: 1px solid #A0A0A0;height:25px;background-color: rgb(255, 255, 255);}''')
        # self.horizontalLayout_7.addWidget(self.lineEdit_3)
        self.pushButton_15 = LoadingButton('        automatically fix this gap',None,FIF.SEND)
        self.pushButton_15.setStyleSheet('''QPushButton{font-weight: bold;background-color:#009faa}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_15.setToolTip("If this gap can be automatically filled, this feature will show the paths to fill the gap")
        self.pushButton_15.clicked.connect(self.get_paths)
        self.horizontalLayout_7.addWidget(self.pushButton_15)
        self.horizontalLayout_7.setStretch(0, 1)
        self.horizontalLayout_7.setStretch(1, 1)
        self.horizontalLayout_7.setStretch(2, 3)
        self.horizontalLayout_7.setStretch(3, 1)
        self.verticalLayout_3.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_3 = StrongBodyLabel('assembly pathway:read IDs')
        self.label_3.setStyleSheet(
            '''QLabel {font-family: "Arial";font-size: 16px;color: #DEA01E;font-weight: bold;}''')
        self.verticalLayout.addWidget(self.label_3)
        self.treeView = MyTableWidget()
        self.treeView.install_eventFilter()
        self.treeView.setColumnCount(1)
        self.treeView.verticalHeader().setHidden(True)
        self.treeView.setRowCount(10000)
        self.treeView.setSelectionBehavior(
            QtWidgets.QAbstractItemView.SelectRows)
        self.treeView.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.verticalLayout.addWidget(self.treeView)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.pushButton_12 = LoadingButton('        fix gap', None, FIF.SEND)
        self.pushButton_12.setStyleSheet(
            '''QPushButton{font-weight: bold;color:#FF0000}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_12.setToolTip("Use the built pathway to fill the gap.")
        self.pushButton_12.clicked.connect(self.delete_path)
        self.horizontalLayout_12.addWidget(self.pushButton_12)
        self.pushButton_11 = LoadingButton('        go back', None, FIF.SEND)
        self.pushButton_11.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_11.setToolTip("Go back one step")
        # self.pushButton_11.clicked.connect(self.return_to_previ)
        self.pushButton_11.clicked.connect(self.reloading)
        self.horizontalLayout_12.addWidget(self.pushButton_11)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.pushButton_13 = LoadingButton('       save', None, FIF.SEND)
        self.pushButton_13.setStyleSheet(
            '''QPushButton{font-weight: bold;color:#FF0000}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_13.setToolTip("save this pathway for restoring")
        self.pushButton_13.clicked.connect(self.temp_save)
        self.horizontalLayout_13.addWidget(self.pushButton_13)
        self.pushButton_14 = LoadingButton('        restore', None, FIF.SEND)
        self.pushButton_14.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_14.setToolTip("restore the saved pathway")
        self.pushButton_14.clicked.connect(self.restore)
        self.horizontalLayout_13.addWidget(self.pushButton_14)
        self.verticalLayout.addLayout(self.horizontalLayout_12)
        self.verticalLayout.addLayout(self.horizontalLayout_13)
        self.label_4 = StrongBodyLabel('the candidate IDs')
        self.label_4.setStyleSheet(
            '''QLabel {font-family: "Arial";font-size: 16px;color:#DEA01E;font-weight: bold;}''')
        self.verticalLayout.addWidget(self.label_4)
        self.treeView_2 = MyTableWidget()
        self.treeView_2.install_eventFilter()
        self.treeView_2.setColumnCount(1)
        self.treeView_2.verticalHeader().setHidden(True)
        self.treeView_2.setSelectionBehavior(
            QtWidgets.QAbstractItemView.SelectRows)
        self.treeView_2.horizontalHeader().setSectionResizeMode(
            QtWidgets.QHeaderView.Stretch)
        self.treeView_2.setRowCount(10000)
        self.treeView_2.clicked.connect(self.show_chr_read)
        self.verticalLayout.addWidget(self.treeView_2)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.pushButton_9 = LoadingButton('        delete', None, FIF.SEND)
        self.pushButton_9.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_9.setToolTip("delete this ID")
        self.pushButton_9.clicked.connect(self.delete_candidate)
        self.pushButton_10 = LoadingButton('        show', None, FIF.SEND)
        self.pushButton_10.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_10.setToolTip("show this ID")
        self.pushButton_10.clicked.connect(self.show_candidate_infor)

        self.horizontalLayout_10.addWidget(self.pushButton_10)
        self.horizontalLayout_10.addWidget(self.pushButton_9)
        self.verticalLayout.addLayout(self.horizontalLayout_10)

        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.pushButton_16 = LoadingButton('        previous', None, FIF.SEND)
        self.pushButton_16.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_16.setToolTip("previous path")
        self.pushButton_16.clicked.connect(self.previous_path)
        self.pushButton_17 = LoadingButton('        next', None, FIF.SEND)
        self.pushButton_17.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_17.setToolTip("next path")
        self.pushButton_17.clicked.connect(self.next_path)
        self.horizontalLayout_14.addWidget(self.pushButton_16)
        self.horizontalLayout_14.addWidget(self.pushButton_17)
        self.verticalLayout.addLayout(self.horizontalLayout_14)
        
        

        self.horizontalLayout_11.addLayout(self.verticalLayout)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.graphicsView = pg.PlotWidget()
        self.graphicsView.setBackground('w')
        pltItem = self.graphicsView.getPlotItem()
        pltItem.showAxis('left', False)
        pltItem.showAxis('bottom', False)
        self.verticalLayout_2.addWidget(self.graphicsView)
        self.mdi = QVBoxLayout()
        self.mdi2 = QtWidgets.QStackedWidget(self.centralwidget)
        style = f'''QStackedWidget {{
                    border-image: url("{self.script_dir}/source/background1.png");
                    background-color: rgb(237, 234, 232);
                }}'''
        self.mdi2.setStyleSheet(style)
        self.mdi.addWidget(self.mdi2)
        self.mdi3 = QVBoxLayout()
        self.treeView_3 = MyTableWidget()
        self.treeView_3.setContextMenuPolicy(Qt.CustomContextMenu)
        self.treeView_3.horizontalHeader().setVisible(True)
        self.treeView_3.setColumnCount(6)
        self.treeView_3.setHorizontalHeaderLabels(
            ['ID', 'match number', 'alignment lenth', 'mapQ', 'kmapQ', 'read length'])
        # 设置第一列宽度为其他列的两倍
        self.treeView_3.setColumnWidth(0, 400)

        # 将其他列的伸缩模式设置为Stretch
        for col in range(1, self.treeView_3.columnCount()):
            self.treeView_3.horizontalHeader().setSectionResizeMode(col, QHeaderView.Stretch)

        self.treeView_3.customContextMenuRequested.connect(self.add_path)
        self.mdi3.addWidget(self.treeView_3)
        self.verticalLayout_2.addLayout(self.mdi)
        self.verticalLayout_2.addLayout(self.mdi3)
        self.verticalLayout_2.setStretchFactor(self.graphicsView, 1)
        self.verticalLayout_2.setStretchFactor(self.mdi, 4)
        self.verticalLayout_2.setStretchFactor(self.mdi3, 0.5)
        self.verticalLayout_2.setStretch(1, 1)
        self.horizontalLayout_11.addLayout(self.verticalLayout_2)
        self.horizontalLayout_11.setStretch(1, 1)
        self.verticalLayout_3.addLayout(self.horizontalLayout_11)
        self.pushButton_10 = LoadingButton(
            '        merge all results', None, FIF.SEND)
        self.pushButton_10.setStyleSheet(
            '''QPushButton{font-weight: bold}QPushButton:hover{color: #ffffff;background-color:#009faa}QPushButton:pressed{color: #ffffff;background-color:#009faa}''')
        self.pushButton_10.setToolTip(
            "merge all results and generate the gapless genome")
        self.pushButton_10.clicked.connect(self.merge_seq)
        self.verticalLayout_3.addWidget(self.pushButton_10)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1523, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.reference_lines = pg.mkPen(color='#042940')  # 参考线颜色
        self.vLine = pg.InfiniteLine(
            angle=90, movable=False, pen=self.reference_lines)
        self.hLine = pg.InfiniteLine(
            angle=0, movable=False, pen=self.reference_lines)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.foldername = ""
        self.gap_num = {}
        self.read_max = []  # 存储最长的read
        self.add_candidate = 0
        self.read_ids = ''
        self.add_pathway = 0
        self.left = 0
        self.right_position = 0
        self.left_start = 1
        self.gap_left = ''
        self.gap_right = ''
        self.ID_location = {}
        self.candidate_infor = {}
        self.treeView_items = 0
        self.ID = ""
        self.flag = 0
        self.join_path_infor = {}
        self.time = ''
        self.target_list = []
        self.merge_result = {}
        self.reads_ID_content = {}  # 收录关于readvsread文件中ID与其信息
        self.target_infor = ''
        self.Congratulations = 0
        self.current_ID = ""
        self.alignment_p = ''
        self.pathway_added = set()
        self.pathway_id_list = []
        self.passed = False
        self.is_first = True
        self.score_true_values = {}  # ;self.score_value={};self.score_values={}
        self.path_order = 0
        self.telo_reads=set()
        self.t1, self.t4, self.t5 = 0.00000045, 0.00000076, 0.00008379

    def open_direction(self):
        a = InfoBar.warning(
            title='tip',
            content="Please wait patiently while loading the corresponding files.",
            orient=Qt.Horizontal,
            isClosable=False,   # disable close button
            position=InfoBarPosition.TOP_LEFT,
            duration=-1,
            parent=self.graphicsView
        )
        directory = QFileDialog.getExistingDirectory(
            self.pushButton_2, "open the folder containing sequence and alingment files")
        self.lineEdit.setText(directory)
        self.open_index()
        a.close()
        InfoBar.success(
            title='finished',
            content='The files have been loaded completely. Now you can select "chr IDs" for further analysis.',
            orient=Qt.Horizontal,    # vertical layout
            isClosable=True,
            position=InfoBarPosition.TOP_LEFT,
            duration=4000,
            parent=self.graphicsView
        )

    def open_index(self):
        name = self.lineEdit.text()
        if name!='':
            if os.path.isfile(name):
                self.foldername = os.path.dirname(name)
            elif os.path.dirname(name):
                self.foldername = name
            files = os.listdir(self.foldername)
            files.sort()
            self.path_file=""
            if len(files) < 8:
                QMessageBox.warning(self.pushButton_2, "Warning",
                                    'The previous program should have produced 8 files, but currently only {} are detected, it seems that some files are missing, please check carefully.'.format(len(files)))
            for file in files:
                filename = os.path.join(self.foldername, file)
                if filename.endswith('map.final.paf'):
                    self.readvschr = filename
                    with open(self.readvschr+".idx", "rb") as f:
                        self.cr_idx = pickle.load(f)
                elif filename.endswith('ovlp.final.paf'):
                    self.readvsread = filename
                    with open(self.readvsread+".idx", "rb") as f:
                        self.rr_idx = pickle.load(f)
                elif filename.endswith('reads.fa') or filename.endswith('reads.fasta') or filename.endswith('reads.fq') or filename.endswith('reads.fastq'):
                    self.read_seq = filename
                elif filename.endswith('chr.fa'):
                    self.index_genome(filename)
                    self.genome_seq = filename
                elif filename.endswith('map.score.txt'):
                    self.map_score = filename
                    with open(self.map_score+".idx", "rb") as f:
                        self.map_score_idx = pickle.load(f)
                elif filename.endswith('ovlp.score.txt'):
                    self.ovlp_score = filename
                    with open(self.ovlp_score+".idx", "rb") as f:
                        self.ovlp_score_idx = pickle.load(f)
                        # print(self.ovlp_score_idx)
                elif filename.endswith('max_reads.txt'):
                    with open(filename) as f:
                        self.read_max = int(f.readline().strip())
                elif filename.endswith("auto_path.txt"):
                    self.path_file=filename

    def cal_score(self, values):
        alpha = [0.00000045, -0.05826849, 0.00302898, 0.00000076, 0.00008379]
        t6 = 0.04249713008044001
        result = [a * b for a, b in zip(alpha, values)]
        return sum(result)+t6

    def index_genome(self, genome):
        with open(genome+".infor.txt") as f:
            for line in f:
                if len(line.split()) > 3:
                    ID, start, end, length = line.split()
                    if ID not in self.gap_num:
                        self.gap_num[ID] = []
                    self.gap_num[ID].append(start+'-'+end)
        for i in self.gap_num:
            if self.comboBox.findText(i) == -1:
                self.comboBox.addItem(i)
        # self.comboBox.addItems(self.gap_num)

    def candidate(self):
        # if self.add_pathway<1:
        infor = self.read_ids
        if infor not in self.candidate_infor:
            self.treeView_2.setItem(
                self.add_candidate, 0, QTableWidgetItem(infor))
            self.add_candidate += 1
            self.candidate_infor[infor] = self.content
        # else:
        #     content="You need to construct a pathway by clicking the 'select + into candidate' or 'select - into candidate' with the right mouse button."
        #     w = InfoBar.warning(title='Warning: ',content=content,isClosable=True,duration=20000,parent=self.svg_widget)
        #     w.setStyleSheet('''QFrame{font-size: 18px;background-color:#fef4ce}''')
        #     w.show()

    # def candidatep(self):
    #     if self.add_pathway>=1:
    #         infor=self.read_ids
    #         self.treeView_2.setItem(self.add_candidate,0,QTableWidgetItem(infor))
    #         self.add_candidate+=1
    #         self.ID_content[infor]=self.target_infor
    #         self.candidate_infor[infor]='+'
    #     else:
    #         content='There is no ID detected in the pathway, you can add it as a candidate by clicking the "add this ID as a candidate" button.'
    #         w = InfoBar.warning(title='Warning: ',content=content,isClosable=True,duration=20000,parent=self.svg_widget)
    #         w.setStyleSheet('''QFrame{font-size: 18px;background-color:#fef4ce}''')
    #         w.show()

    # def candidaten(self):
    #     if self.add_pathway>=1:
    #         infor=self.read_ids
    #         self.treeView_2.setItem(self.add_candidate,0,QTableWidgetItem(infor))
    #         self.add_candidate+=1
    #         self.ID_content[infor]=self.target_infor
    #         self.candidate_infor[infor]='-'
    #     else:
    #         content='There is no ID detected in the pathway, you can add it as a candidate by clicking the "add this ID as a candidate" button.'
    #         w = InfoBar.warning(title='Warning: ',content=content,isClosable=True,duration=20000,parent=self.svg_widget)
    #         w.setStyleSheet('''QFrame{font-size: 18px;background-color:#fef4ce}''')
    #         w.show()

    def clear_content(self):
        self.treeView_2.clearContents()
        self.add_candidate = 0

    def lefts(self):
        self.left = 1
        self.right = 0

    def rights(self):
        self.left = 0
        self.right = 1

    def temp_save(self):
        chrid = self.comboBox.currentText()
        gap_range = self.comboBox_2.currentText()
        file = open(f'{self.foldername}/temp_save.bin', 'wb')
        pickle.dump((chrid, gap_range, self.target_set, self.flag_ID, self.gap_num, self.read_max, self.add_candidate, self.read_ids, self.add_pathway,
                     self.left, self.right_position, self.left_start, self.gap_left, self.gap_right,
                     self.ID_location, self.ID, self.flag, self.join_path_infor, self.time, self.target_list,
                     self.merge_result, self.reads_ID_content, self.target_infor, self.Congratulations,
                     self.current_ID, self.alignment_p, self.pathway_added, self.pathway_id_list, self.passed, self.is_first), file)
        file.close()

    def restore(self):

        with open(f'{self.foldername}/temp_save.bin', "rb") as f:
            chrid, gap_range, self.target_set, self.flag_ID, self.gap_num, self.read_max, self.add_candidate, self.read_ids, self.add_pathway, \
                self.left, self.right_position, self.left_start, self.gap_left, self.gap_right, \
                self.ID_location, self.ID, self.flag, self.join_path_infor, self.time, \
                self.target_list, self.merge_result, self.reads_ID_content, \
                self.target_infor, self.Congratulations, self.current_ID, self.alignment_p, self.pathway_added, \
                self.pathway_id_list, self.passed, self.is_first = pickle.load(
                    f)
        # print((self.gap_num,self.read_max,self.add_candidate,self.read_ids,self.add_pathway,
        #              self.left,self.right_position,self.left_start,self.gap_left,self.gap_right,
        #              self.ID_location,self.candidate_infor,self.ID,self.flag,
        #              self.join_path_infor,self.time,self.target_list,self.merge_result,self.reads_ID_content,
        #              self.target_infor,self.Congratulations,self.current_ID,self.alignment_p,self.pathway_added,
        #              self.pathway_id_list,self.passed,self.is_first))
        self.comboBox.setCurrentText(chrid)
        self.comboBox_2.setCurrentText(gap_range)
        for i, (p, ID) in enumerate(self.pathway_id_list):
            self.treeView.setItem(i, 0, QTableWidgetItem(ID))
        self.draw_readvsread(ID)
        self.scatter1.scene().sigMouseMoved.connect(self.mouseover2)  # 这两句是获取坐标位置
        self.scatter1.scene().sigMouseClicked.connect(self.mouse_clicked2)
        pg.SignalProxy(self.scatter1.scene().sigMouseMoved,
                       rateLimit=60, slot=self.mouseover2)

    def pathway(self):
        # if self.add_pathway<1:
        if self.path_order >0:
            row_number = self.treeView_2.currentRow()
            read_ID = self.treeView_2.currentItem().text()
            del self.candidate_infor[read_ID]
            self.treeView_2.removeRow(row_number)
            self.path_order -= 1
        self.read_position.clear()
        self.readvsread_y.clear()
        index = self.treeView_3.currentIndex()
        linelist = self.content[index.row()].split()
        if self.add_pathway < 1:
            self.current_ID = linelist[0]
            self.alignment_p = linelist[4]
            if self.current_ID in self.ID_left:
                self.target_set = self.ID_right
                self.ID_left.clear()
            else:
                self.target_set = self.ID_left
                self.left_start = 0
                self.ID_right.clear()
        else:
            # print(linelist[0],self.current_ID)
            if linelist[0] == self.current_ID:
                linelist[0:4], linelist[5:9] = linelist[5:9], linelist[0:4]
            if linelist[4] == self.alignment_p:
                self.alignment_p = '+'
            else:
                self.alignment_p = '-'
        qid = linelist[0]
        ql = int(linelist[1])
        ref_s = int(linelist[7])
        ref_e = int(linelist[8])
        que_s = int(linelist[2])
        que_e = int(linelist[3])
        direction = linelist[4]
        if '_' in self.comboBox_2.currentText():
            fa=pyfastx.Fasta(self.read_seq)
            seq=fa[qid]
            unit_seq_reverse=self.reverse_complement(self.unit_seq)
            number1=str(seq).count(self.unit_seq);number2=str(seq).count(unit_seq_reverse)
            if number1>=200 or number2>=200:
                self.target_list.append(qid)
                self.join_path_infor[qid] = [qid, -2, (ref_s, ref_e), (que_s, que_e), direction]
                content = 'The number of repeated units contained in the read you selected is more than 200. Now, click the "fix gap" button to complete the filling.'
                w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                    duration=4000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.show()
                return

        if self.passed:
            linelist = self.content[index.row()].split()
            qid = linelist[0]
            ql = int(linelist[1])
            ref_s = int(linelist[7])
            ref_e = int(linelist[8])
            que_s = int(linelist[2])
            que_e = int(linelist[3])
            direction = linelist[4]
            if len(self.ID_left) == 0:
                qid = "right"
            else:
                qid = "left"
            # print(qid, -1, (que_s, que_e), (ref_s, ref_e), direction)
            self.join_path_infor[qid] = [
                qid, -1, (que_s, que_e), (ref_s, ref_e), direction]
            # print(self.join_path_infor)
            # print(self.join_path_infor)
            self.treeView.setItem(self.add_pathway, 0, QTableWidgetItem(qid))
            self.target_list.append(qid)
            content = 'We have detected that the ID that has just been added to the pathway has completed gap filling. Now, click the "fix gap" button to complete the filling.'
            w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                duration=-1, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
            w.show()
        else:
            self.join_path_infor[qid] = [
                qid, ql, (ref_s, ref_e), (que_s, que_e), direction]  # 通路信息
            self.current_ID = qid
            self.pathway_id_list.append((self.alignment_p, self.current_ID))
            self.treeView.setItem(self.add_pathway, 0, QTableWidgetItem(qid))
            self.target_list.append(qid)
            self.pathway_added.add(qid)
            self.add_pathway += 1
            if self.add_candidate >0:
                self.candidate_infor.clear()
                self.treeView_2.clear()
            self.add_candidate = 0
            self.treeView_items += 1
            self.draw_readvsread(qid)
        self.clear_svg()
        self.treeView_3.clearContents()
        # self.treeView_3.clicked.disconnect()
        if self.add_pathway < 1:
            if qid in self.across_ID:
                content = 'We have detected that the ID that has just been added to the pathway has completed gap filling. Now, click the "fix gap" button to complete the filling.'
                w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                    duration=4000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.show()  # 需不需要写show需要进一步验证
            elif qid in self.both_ID:
                content = 'This ID is detected on both sides of the gap, but we consider it unreliable. It is recommended to select other IDs to build the pathway. Or if you still want to select this ID, please click "left" or "right" button to provide information.'
                w = InfoBar.warning(title='warning!', content=content, isClosable=True,
                                    duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.show()  # 需不需要写show需要进一步验证
                self.left_button = PushButton('left shore')
                self.left_button.clicked.connect(self.lefts)
                w.addWidget(self.left_button)
                self.right_button = PushButton('right shore')
                self.right_button.clicked.connect(self.rights)
                w.addWidget(self.right_button)
        else:
            if qid in self.target_set:
                self.passed = True
                content = self.target_set[qid]
                self.draw_read(content, './draw_gap.svg')
                self.mdi2.setStyleSheet(
                    '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
                self.clear_svg()
                self.svg_widget = QSvgWidget()
                self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
                self.svg_widget.customContextMenuRequested.connect(
                    self.right_menu)
                self.svg_widget.load('./draw_gap.svg')
                self.mdi.addWidget(self.svg_widget)
                self.treeView_3.clicked.disconnect()
                self.treeView_3.clicked.connect(self.show_highlight)
                content = 'The pathway you built has been across the gap region. You need select a particular alignment infomration for filling this gap or you can click the "go back" button to select another ID'
                w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                    duration=4000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.show()  # 需
    def add_path(self, pos):
        if self.treeView_3.itemAt(pos) is None:
            return
        index = self.treeView_3.currentIndex()
        if index.isValid():  # and index.column()==0:
            if self.read_ids not in self.pathway_added or self.passed:
                menu = QMenu()
                action = QAction('add this alignment in path')
                action.triggered.connect(lambda: self.pathway())
                menu.addAction(action)
                menu.exec_(self.treeView_3.viewport().mapToGlobal(pos))
                
            else:
                InfoBar.success(
                    title='Note !',
                    content='The ID you have selected has already been added into the pathway. Please choose another ID for further actions.',
                    orient=Qt.Horizontal,    # vertical layout
                    isClosable=True,
                    position=InfoBarPosition.TOP_LEFT,
                    duration=4000,
                    parent=self.graphicsView
                )

    def align_infor(self):
        target = ''.join(self.target_infor)
        view = TeachingTipView(
            icon=InfoBarIcon.SUCCESS, title='alignment information', content=target, isClosable=True)
        w = TeachingTip.make(target=self.svg_widget, view=view, duration=-1)
        # view.setStyleSheet('''QFrame{font-size: 20px}''')
        view.closed.connect(w.close)

    def help(self):
        with open('./source/help.txt') as f:
            content = ''.join(f.readlines())
        InfoBar.success(
            title='help information',
            content=content,
            orient=Qt.Horizontal,    # vertical layout
            isClosable=True,
            position=InfoBarPosition.TOP_LEFT,
            duration=-1,
            parent=self.graphicsView
        )

    def showwindow(self):
        newWindow = loginviewer()
        qe = QEventLoop()
        qe.exec_()
    def get_path_algin_infor(self,chrid,path):
        pre_id=path[0]
        if pre_id not in self.ID_content:
            with open(self.map_score) as f:
                f.seek(self.map_score_idx[chrid])
                for line in f:
                    id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                    if id2 != chrid:
                        break
                    if id1==pre_id:
                        k = (id1, id2, dir)
                        v1 = int(v1)
                        v2 = float(v2)
                        v3 = float(v3)
                        v4 = int(v4)
                        v5 = int(v5)  # 后续需要加上v5
                        self.score_true_values[k] = (v1, v2, v3, v4, v5)
            with open(self.readvschr) as f:
                f.seek(int(self.cr_idx[chrid]))
                for line in f:
                    linelist = line.split()
                    read_ID = linelist[0]
                    if read_ID not in self.ID_content:
                        self.ID_content[read_ID] = []
                    if read_ID == pre_id :
                        self.ID_content[read_ID].append(line)
        with open(self.ovlp_score) as fs, open(self.readvsread) as fp :
            for read_id in path[1:]:
                if read_id not in self.reads_ID_content:
                    for idx in self.ovlp_score_idx[read_id] :
                        fs.seek(idx)
                        for line in fs:
                            id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                            if id1 != read_id and id2 != read_id:
                                break
                            k = (id1, id2, dir)
                            v1 = int(v1)
                            v2 = float(v2)
                            v3 = float(v3)
                            v4 = int(v4)
                            v5 = int(v5)  # 后续需要加上v5
                            self.score_true_values[k] = (v1, v2, v3, v4, v5)
                    for lineindex in self.rr_idx[read_id]:
                        fp.seek(lineindex)
                        for line in fp:
                            linelist = line.split()
                            if linelist[0] != read_id and linelist[5] != read_id:
                                break
                            if read_id not in self.reads_ID_content:
                                self.reads_ID_content[read_id]=[]
                            self.reads_ID_content[read_id].append(line)
                pre_id=read_id
    
    def get_paths(self):
        if self.path_file !="":
            chrid = self.comboBox.currentText()
            gap_range = self.comboBox_2.currentText()
            start,end=gap_range.split("-")
            self.paths=[]
            self.view_path=0
            self.path_order=0
            with open(self.path_file,"r") as f:
                for line in f:
                    line=line.strip().split()
                    # print(f"###{line[0]}###{chrid}##{int(line[1])}##{start}##")
                    if line[0] == chrid and line[1]== start :
                        # print(1)
                        self.paths.append(line[2:])
            if len(self.paths)<1:
                w = InfoBar.warning(title='warning!', content="There is no path to display for this gap.", isClosable=True,
                            duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.show()             
            self.get_path_algin_infor(chrid,self.paths[self.view_path])
            # print(self.reads_ID_content)
            pre_id=self.paths[self.view_path][0]
            for read_id in self.paths[self.view_path]:
                self.treeView_2.setItem(self.path_order, 0, QTableWidgetItem(read_id))
                if self.path_order==0:
                    self.candidate_infor[read_id] = self.ID_content[read_id]
                else:
                    alignments=self.reads_ID_content[read_id]
                    alignment = [line for line in alignments if pre_id+'\t' in line]
                    self.candidate_infor[read_id] = alignment
                    pre_id=read_id
                self.path_order +=1              
               
        else:
            content='You need to run auto_find_path.py first and put the resulting file in the workdir directory'
            w = InfoBar.warning(title='warning!', content=content, isClosable=True,
                            duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
            w.show()
    def previous_path(self):
        if self.view_path > 0:  
            chrid = self.comboBox.currentText()
            self.candidate_infor.clear()
            self.view_path -=1 
            self.treeView_2.clear()
            self.path_order=0
            pre_id=self.paths[self.view_path][0]
            self.get_path_algin_infor(chrid,self.paths[self.view_path])
            for read_id in self.paths[self.view_path]:
                self.treeView_2.setItem(self.path_order, 0, QTableWidgetItem(read_id))
                if self.path_order==0:
                    self.candidate_infor[read_id] = self.ID_content[read_id]
                else:
                    alignments=self.reads_ID_content[read_id]
                    alignment = [line for line in alignments if pre_id+'\t' in line]
                    self.candidate_infor[read_id] = alignment
                    pre_id=read_id
                self.path_order +=1
        else:
            return 
    def next_path(self):
        chrid = self.comboBox.currentText()
        self.view_path +=1 
        if self.view_path < len(self.paths)  : 
            self.candidate_infor.clear()
            self.treeView_2.clear()
            self.path_order=0
            pre_id=self.paths[self.view_path][0]
            self.get_path_algin_infor(chrid,self.paths[self.view_path])
            for read_id in self.paths[self.view_path]:
                self.treeView_2.setItem(self.path_order, 0, QTableWidgetItem(read_id))
                if self.path_order==0:
                    self.candidate_infor[read_id] = self.ID_content[read_id]
                else:
                    alignments=self.reads_ID_content[read_id]
                    alignment = [line for line in alignments if pre_id+'\t' in line]
                    self.candidate_infor[read_id] = alignment
                    pre_id=read_id               
                self.path_order +=1
        else:
            w = InfoBar.warning(title='warning!', content="You have already viewed all the paths. Please select the previous path or choose a path manually.", isClosable=True,
                            duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
            w.show() 
       
    
    
    
    def delete_candidate(self):
        if self.add_candidate < 1:
            return
        row_number = self.treeView_2.currentRow()
        read_ID = self.treeView_2.currentItem().text()
        del self.candidate_infor[read_ID]
        self.treeView_2.removeRow(row_number)

    def show_candidate_infor(self):
        # print(self.path_order)
        if self.path_order>0:
            self.treeView_3.clicked.disconnect()
            self.treeView_3.clicked.connect(self.show_highlight)
            self.passed=False
        if self.add_candidate < 1 and self.path_order <1:
            return
        read_ID = self.treeView_2.currentItem().text()
        alignments = self.candidate_infor[read_ID]
        if self.add_pathway < 1:
            self.draw_read(alignments, './draw_gap.svg')
            # self.draw_read2(alignments,'./draw_gap.svg')
            self.mdi2.setStyleSheet(
                '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
            self.clear_svg()
            self.svg_widget = QSvgWidget()
            self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
            self.svg_widget.customContextMenuRequested.connect(self.right_menu)
            self.svg_widget.load('./draw_gap.svg')
            self.mdi.addWidget(self.svg_widget)
        else:
            self.draw_read2(alignments, './draw_readvsread.svg')
            self.mdi2.setStyleSheet(
                '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
            self.clear_svg()
            self.svg_widget = QSvgWidget()
            self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
            self.svg_widget.customContextMenuRequested.connect(
                self.right_menu2)
            self.svg_widget.load('./draw_readvsread.svg')
            self.mdi.addWidget(self.svg_widget)

    def reverse_complement(self, sequence):  # get reverse&complement sequence
        trantab = str.maketrans('ACGTacgt', 'TGCAtgca')
        string = sequence.translate(trantab)
        return string[::-1]

    def get_reads(self, reads, reads_file):
        flag = 0
        with open(reads_file, "r") as f:
            line = f.readline()
            name = line.strip().split()[0][1:]
            if name in reads.keys():
                flag = 1
            if line[0] == '>':
                for line in f:
                    line = line.strip()
                    if line[0] == '>':
                        name = line.split()[0][1:]
                        if name in reads.keys():
                            flag = 1
                        else:
                            flag = 0
                    else:
                        if flag:
                            reads[name] = "".join([reads[name], line])
            elif line[0] == '@':
                i = 0
                for line in f:
                    line = line.strip()
                    i += 1
                    if i % 4 == 0:
                        name = line.split()[0][1:]
                        if name in reads.keys():
                            flag = 1
                        else:
                            flag = 0
                    elif i % 4 == 1:
                        if flag:
                            reads[name] = "".join([reads[name], line])
            else:
                raise Exception("Error fastx format!")

    def path_to_sequence(self, path, reads_file):
        
        # reads = {item[0]: "" for item in path}
        # self.get_reads(reads, reads_file)
        reads=pyfastx.Fasta(reads_file)
        # print(path)
        if len(path) == 1:
            item=path[0]
            # qid,ql,(ref_s,ref_e),(que_s,que_e),direction
            s, e = item[2]
            qs, qe = item[3]
            seq=str(reads[item[0]])
            if 'left' in self.comboBox_2.currentText():
                if item[4] == "+":
                    return [0,s,seq[:qs]]
                else:
                    return [0,s, self.reverse_complement(seq[qe:])]
            elif "right" in self.comboBox_2.currentText():
                if item[4] == "+":
                    return [e,-1,seq[:qs]]
                else:
                    return [e,-1, self.reverse_complement(seq[qe:])]
            else:
                if item[4] == '+':
                    return [s, e, seq[qs:qe]]
                else:
                    return [s, e, self.reverse_complement(seq[qs:qe])]
        seqs = []
        flag = 0

        
        if 'left' in self.comboBox_2.currentText():
            pre_rs,pre_re=path[0][2]
            pre_qs,pre_qe=path[0][3]
            direction=path[0][4]
            for item in path[1:]:
                seq=str(reads[item[0]])
                rs,re=item[2]
                if direction == '-' and flag == 0:
                    seqs.append(self.reverse_complement(seq[pre_qe:re]))
                    flag = 1
                elif direction == '-' and flag == 1:
                    seqs.append(seq[rs:pre_qs])
                    flag = 0
                elif direction == '+' and flag == 1:
                    seqs.append(self.reverse_complement(seq[pre_qe:re]))
                    flag = 1
                else:
                    seqs.append(seq[rs:pre_qs])
                pre_rs,pre_re = item[2]
                pre_qs,pre_qe = item[3]
                direction=item[4]
            if direction == '-' and flag == 0:
                    seqs.append(self.reverse_complement(seq[pre_qe:]))
                    flag = 1
            elif direction == '-' and flag == 1:
                seqs.append(seq[:pre_qs])
                flag = 0
            elif direction == '+' and flag == 1:
                seqs.append(self.reverse_complement(seq[pre_qs:]))
                flag = 1
            else:
                seqs.append(seq[:pre_qs])
            return [0,path[-1][2][0],"".join(seqs)]
        elif "right" in self.comboBox_2.currentText():
            pre_rs,pre_re=path[0][2]
            pre_qs,pre_qe=path[0][3]
            direction=path[0][4]
            for item in path[1:]:
                seq=str(reads[item[0]])
                rs,re=item[2]
                if direction == '-' and flag == 0:
                    seqs.append(self.reverse_complement(seq[rs:pre_qs]))
                    flag = 1
                elif direction == '-' and flag == 1:
                    seqs.append(seq[pre_qe:re])
                    flag = 0
                elif direction == '+' and flag == 1:
                    seqs.append(self.reverse_complement(seq[rs:pre_qs]))
                    flag = 1
                else:
                    seqs.append(seq[pre_qe:re])
                pre_rs,pre_re = item[2]
                pre_qs,pre_qe = item[3]
                direction=item[4]
            if direction == '-' and flag == 0:
                    seqs.append(self.reverse_complement(seq[:pre_qs]))
                    flag = 1
            elif direction == '-' and flag == 1:
                seqs.append(seq[pre_qe:])
                flag = 0
            elif direction == '+' and flag == 1:
                seqs.append(self.reverse_complement(seq[:pre_qs]))
                flag = 1
            else:
                seqs.append(seq[pre_qe:])
            
            return [path[-1][2][1],-1,"".join(seqs)]
        

        if "left" in reads.keys():
            path = path[::-1]
            for i in range(len(path)-1):
                path[i][:2] = path[i+1][:2]
            path[-1][:2] = ["right", -1]
        pos = []
        pos.append(['left', 0, 0])
        pre_len = 0
        for item in path:
            pre_start, pre_end = item[2]
            cur_start, cur_end = item[3]
            length = item[1]
            if item[4] == '-' and flag == 0:
                cur_start, cur_end = length-cur_end, length-cur_start
                flag = 1
            elif item[4] == '-' and flag == 1:
                pre_start, pre_end = pre_len-pre_end, pre_len-pre_start
                flag = 0
            elif item[4] == '+' and flag == 1:
                pre_start, pre_end = pre_len-pre_end, pre_len-pre_start
                cur_start, cur_end = length-cur_end, length-cur_start
                flag = 1
            # pos[-1].append(pre_start)
            # pos.append([item[0], flag, cur_start])
            # pre_len = length
            pos[-1].append(pre_end)
            pos.append([item[0],flag,cur_end])
            pre_len=length
        pos[-2][-1]=pre_start
        pos[-1][-1]=cur_start
        sum_len=0
        for read in pos:
            if read[0] == 'left':
                # seqs.append(chr_seq[read[2]:read[3]])
                s = read[3]
            elif read[0] == 'right':
                # seqs.append(chr_seq[read[2]:])
                e = read[2]
            else:
                seq=str(reads[read[0]])
                sum_len+=(read[3]-read[2])
                if read[1] == 0:
                    seqs.append(seq[read[2]:read[3]])
                else:
                    seqs.append(self.reverse_complement(seq)[read[2]:read[3]])
        # print(sum_len,s,e,file=sys.stderr)
        # print("".join(seqs),file=sys.stderr)
        return [s, e, "".join(seqs)]

    def delete_path(self):
        path = [self.join_path_infor[i] for i in self.target_list]
        # print(path)
        fa_file = self.read_seq
        t_dir = self.path_to_sequence(path, fa_file)
        chrid = self.comboBox.currentText()
        if chrid not in self.merge_result:
            self.merge_result[chrid] = []
        self.merge_result[chrid].append(t_dir)
        self.join_path_infor = {}
        self.target_list = []
        self.treeView.clear()
        InfoBar.success(
            title='Note !',
            content='You have successfully filled this gap, and you can choose the next gap.',
            orient=Qt.Horizontal,    # vertical layout
            isClosable=True,
            position=InfoBarPosition.TOP_LEFT,
            duration=4000,
            parent=self.graphicsView
        )

    def merge_seq(self):
        chr_info = self.merge_result
        scf_file = self.genome_seq
        output = scf_file+'_gap_filling_version.fa'
        filled_seq=scf_file+'_filled_seq.fa'
        fa = open(scf_file, "r")
        fo = open(output, "w")
        fo2=open(filled_seq,"w")
        seqs = []
        first=True
        for line in fa:
            line=line.strip()
            if line[0] == '>':
                if first:
                    name = line.split()[0][1:]
                    first=False
                else:
                    seq="".join(seqs)
                    if name in chr_info:
                        v = sorted(chr_info[name], key=lambda x: x[0])
                        final_seqs = []
                        s = 0
                        for item in v:
                            fo2.write(f">{name} {item[0]}-{item[1]}\n")
                            fo2.write(item[2])
                            fo2.write("\n")
                            if item[0] ==0:
                                final_seqs.append(item[2])
                                s=item[1]
                                continue
                            final_seqs.append(seq[s:item[0]])
                            final_seqs.append(item[2])
                            s = item[1]
                        if v[-1][1] != -1:
                            final_seqs.append(seq[s:])
                        fo.write(f">{name}\n")
                        fo.write("".join(final_seqs))
                        fo.write("\n")
                    else:
                        fo.write(f">{name}\n")
                        fo.write(seq)
                        fo.write("\n")
                    name = line.split()[0][1:]
                    seqs=[]
                    del seq
            else:
                seqs.append(line)
        seq="".join(seqs)
        if name in chr_info:
            v = sorted(chr_info[name], key=lambda x: x[0])
            final_seqs = []
            s = 0
            for item in v:
                fo2.write(f">{name} {item[0]}-{item[1]}\n")
                fo2.write(item[2])
                fo2.write("\n")
                if item[0] ==0:
                    final_seqs.append(item[2])
                    s=item[1]
                    continue
                final_seqs.append(seq[s:item[0]])
                final_seqs.append(item[2])
                s = item[1]
            if v[-1][1] != -1:
                final_seqs.append(seq[s:])
            fo.write(f">{name}\n")
            fo.write("".join(final_seqs))
            fo.write("\n")
        else:
            fo.write(f">{name}\n")
            fo.write(seq)
            fo.write("\n")
        fa.close()
        fo.close()
        fo2.close()
        self.pushButton_10.setText('       finished !!')



    def right_menu(self):  # 创建右键菜单的方法
        self.groupBox_menu = QMenu(self.svg_widget)
        # self.actionA = self.contextMenu.addAction(QIcon("images/0.png"),u'|  动作A')
        self.actionA = QAction('add this ID as a candidate')
        # self.actionA.setText(QCoreApplication.translate("MainWindow", "add this ID as a candidate"))
        self.groupBox_menu.addAction(self.actionA)

        self.actionC = QAction(QIcon(f'{self.script_dir}/source/help.png'), 'Help')
        self.groupBox_menu.addAction(self.actionC)

        self.actionA.triggered.connect(self.candidate)  # 将右键添加的功能连接到相应功能
        self.actionC.triggered.connect(self.help)
        self.groupBox_menu.exec_(QCursor.pos())  # 这句不能少

    def right_menu2(self):  # 创建右键菜单的方法
        self.groupBox_menu = QMenu(self.svg_widget)
        # self.actionA = self.contextMenu.addAction(QIcon("images/0.png"),u'|  动作A')
        self.actionA = QAction('add this ID as a candidate')
        self.groupBox_menu.addAction(self.actionA)

        self.actionB = QAction('show detail alignment information')
        self.groupBox_menu.addAction(self.actionB)

        self.actionC = QAction(QIcon(f'{self.script_dir}/source/help.png'), 'Help')
        self.groupBox_menu.addAction(self.actionC)

        self.actionA.triggered.connect(self.candidate)  # 将右键添加的功能连接到相应功能
        # self.actionB.triggered.connect(self.pathway)
        self.actionB.triggered.connect(self.align_infor)
        self.actionC.triggered.connect(self.help)
        # self.actionD.triggered.connect(self.positive)
        # self.actionE.triggered.connect(self.negative)
        # self.actionF.triggered.connect(self.candidatep)
        # self.actionG.triggered.connect(self.candidaten)
        self.groupBox_menu.exec_(QCursor.pos())  # 这句不能少

    def reverse_complement(self,sequence):
        trantab = str.maketrans('ACGTacgt', 'TGCATGCA')
        string = sequence.translate(trantab)
        reverse_complement = string[::-1]
        return reverse_complement
    
    def search_telomere(self):
        self.unit_seq=self.lineEdit_3.text().upper()
        if self.unit_seq=='':
            self.lineEdit_3.setStyleSheet(
            '''QLineEdit{border-radius:5px;font-size:10pt;font-family:"Arial";border: 1px solid #A0A0A0;color:#FF0000;height:25px;background-color: rgb(255, 255, 255);}''')
            self.lineEdit_3.setText('Please enter the monomer sequence of the telomere.')
            return -1
        else:
            unit_seq_reverse=self.reverse_complement(self.unit_seq)
            id_seq={}
            try:
                fa_seq=pyfastx.Fasta(self.genome_seq)
                for chr in fa_seq:
                    name=chr.name
                    seqs=chr.seq
                    seq_length=len(seqs)
                    if name not in id_seq:id_seq[name]=[]
                    id_seq[name].append(seqs[0:1000])
                    id_seq[name].append(seqs[1001:2000])
                    id_seq[name].append(seqs[2001:3000])
                    id_seq[name].append(seqs[-1000:])
                    id_seq[name].append(seqs[-2000:-1000])
                    id_seq[name].append(seqs[-3000:-2000])
            except:
                with open(self.genome_seq) as f:
                    t=[line.strip().split()[0]+'%' if '>' in line else line.strip().split()[0] for line in f]
                    fa_seq=''.join(t).split('>')[1:]
                    for chr in fa_seq:
                        infor=chr.split('%')
                        name=infor[0];seqs=infor[1]
                        seq_length=len(seqs)
                        if name not in id_seq:id_seq[name]=[]
                        id_seq[name].append(seqs[0:1000])
                        id_seq[name].append(seqs[1001:2000])
                        id_seq[name].append(seqs[2001:3000])
                        id_seq[name].append(seqs[-1000:])
                        id_seq[name].append(seqs[-2000:-1000])
                        id_seq[name].append(seqs[-3000:-2000])
                        seqs=''
            del fa_seq
            for name,u in id_seq.items():
                count=0
                for j in u[:3]:
                    j=j.upper()
                    repeat_number=len(re.findall(re.escape(self.unit_seq), j))+len(re.findall(re.escape(unit_seq_reverse), j))
                    if repeat_number>=100:
                        count+=repeat_number
                if count==0:id_seq[name]=['left_telomere']
                else:id_seq[name]=[]
                count=0
                for j in u[4:]:
                    repeat_number=len(re.findall(re.escape(self.unit_seq), j))+len(re.findall(re.escape(unit_seq_reverse), j))
                    if repeat_number>=100:
                        count+=repeat_number
                if count==0:id_seq[name].append('right_telomere '+str(seq_length))
            for id,pos in id_seq.items():
                if len(pos)>0 :
                    if id in self.gap_num :
                        self.gap_num[id]+=pos
                    else:
                        self.comboBox.addItem(id)
                        self.gap_num[id] = pos
            InfoBar.success(
            title='Note !',
            content='the chromosomes with lacking telomeres have been added',
            orient=Qt.Horizontal,    # vertical layout
            isClosable=True,
            position=InfoBarPosition.TOP_LEFT,
            duration=4000,
            parent=self.graphicsView
            )

            return 0
    
    def selectionchange(self):
        self.comboBox_2.clear()
        self.comboBox_2.addItem(
            'Please wait patiently while the data is loading...')
        QApplication.processEvents()
        self.comboBox_2.clear()
        ID = self.comboBox.currentText()
        
        if ID in self.gap_num:
            self.comboBox_2.addItems(self.gap_num[ID])
        # a.close()
    def show_potentials(self):
        self.left_start = 1
        self.ID_check = 0
        self.readvsread_y = {}
        self.light_list = []
        self.ID_length = {}
        self.flag_ID = {}
        self.drawn_ID = {}
        self.ID_left = {}
        self.ID_right = {}
        self.across_ID = set()
        self.both_ID = set()  # both_ID收录了在两边但是没有跨过去的
        self.left_group = {}
        self.right_group = {}
        self.cross_group = {}
        self.score_true_values = {}
        self.reads_ID_content={}
        self.Congratulations = 0
        cr_file = self.readvschr
        chrid = self.comboBox.currentText()
        gap_infor=self.comboBox_2.currentText()
        gap_range = gap_infor.split('-')
        self.ID_location = {}
        self.color_level = {1: '#FC0505', 2: '#C44F70', 3: '#FF85A3'}
        unit = 10**-(len(str(self.read_max))-2)
        read_lines = pg.mkPen(color='#F2B950', width=8)
        if '-' in gap_infor and gap_range[0] != '':
            s, e = int(gap_range[0])*unit, int(gap_range[1])*unit
            self.unit = unit
            self.max_read = self.read_max*unit
            self.graphicsView.clear()
            x = [1, 1+self.max_read]
            y = [100, 100]
            self.gap_left = x
            gap_region = pg.mkPen(color="#025949", width=4)
            self.scatter1 = self.graphicsView.plot(x, y, pen=gap_region)
            vLine = pg.InfiniteLine(angle=90, movable=False)
            self.graphicsView.addItem(vLine, ignoreBounds=True)
            vLine.setPos(1+self.max_read)
            x = [1+self.max_read*4, 1+self.max_read*5]
            y = [100, 100]
            self.gap_right = x
            self.graphicsView.plot(x, y, pen=gap_region)
            vLine2 = pg.InfiniteLine(angle=90, movable=False)
            self.graphicsView.addItem(vLine2, ignoreBounds=True)
            self.x_thre = 1+self.max_read*4  # 用于实时显示ID与value
            vLine2.setPos(1+self.max_read*4)
            with open(self.map_score) as f:
                f.seek(self.map_score_idx[chrid])
                for line in f:
                    id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                    if id2 != chrid:
                        break
                    k = (id1, id2, dir)
                    v1 = int(v1)
                    v2 = float(v2)
                    v3 = float(v3)
                    v4 = int(v4)
                    v5 = int(v5)  # 后续需要加上v5
                    self.score_true_values[k] = (v1, v2, v3, v4, v5)
            cr_index = self.cr_idx
            with open(cr_file) as f:
                self.read_position = {}
                self.ID_content = {}
                self.alignment_position = {}
                self.left_id_position = {}
                f.seek(int(cr_index[chrid]))
                content = {}
                n = 0
                # x1 = 0
                yl = 0
                yr = 0
                for line in f:
                    x1 = 0
                    linelist = line.split()
                    refs = int(linelist[7])*unit
                    refe = int(linelist[8])*unit
                    readlength = int(linelist[1])*unit
                    read_ID = linelist[0]
                    alignment_qua = int(linelist[9])
                    reade = int(linelist[3])*unit
                    reads = int(linelist[2])*unit
                    direction = linelist[4]
                    kmer = float(linelist[-1])
                    refeid = linelist[5]
                    self.ID_length[read_ID] = int(linelist[1])
                    if read_ID not in self.drawn_ID:
                        self.drawn_ID[read_ID] = []
                    key = (read_ID, refeid, direction)
                    # alignment_length = refe-refs
                    # if 0 <= alignment_qua < 20:
                    #     level = 3
                    # elif 20 <= alignment_qua < 40:
                    #     level = 2
                    # elif 40 <= alignment_qua:
                    #     level = 1
                    # read_lines = pg.mkPen(color='#F2B950', width=8)
                    if refeid != chrid:
                        break
                    if refs <= s < e <= refe:
                        n += 1
                        if refs < s-self.max_read:
                            x1 = 1
                        elif s-self.max_read <= refs:
                            x1 = (refs-(s-self.max_read))+1
                        if refe >= e+self.max_read:
                            x2 = 1+self.max_read*5
                        elif refe < e+self.max_read:
                            x2 = 1+self.max_read*4+refe-e
                        if direction == '-':
                            self.flag_ID[read_ID] = 1
                        else:
                            self.flag_ID[read_ID] = 0
                        self.across_ID.add(read_ID)
                        self.cross_group[key] = (x1, x2)
                    elif s >= refe:
                        gap_length = s-refs
                        # if alignment_length/gap_length>=0.8:
                        if direction == "+":
                            if s-refe < readlength-reade:
                                x1 = 1+self.max_read-(s-refe)-reade
                                x2 = x1+readlength
                                n += 1
                                self.flag_ID[read_ID] = 0
                                self.left_group[key] = (x1, x2)
                                if s-refe <= 10000:
                                    if read_ID not in self.ID_left:
                                        self.ID_left[read_ID] = []
                                    self.ID_left[read_ID].append(line)
                            else:
                                continue
                        else:
                            if s-refe < reads:
                                x1 = 1+self.max_read-s+refe+reads-readlength
                                x2 = x1+readlength
                                n += 1
                                self.flag_ID[read_ID] = 1
                                self.left_group[key] = (x1, x2)
                                if s-refe <= 10000:
                                    if read_ID not in self.ID_left:
                                        self.ID_left[read_ID] = []
                                    self.ID_left[read_ID].append(line)
                            else:
                                continue
                    elif e <= refs:
                        gap_length = refe-e
                        # if alignment_length/gap_length>=0.8:
                        if direction == '+':
                            if reads > refs-e:
                                x1 = 1+4*self.max_read+refs-e-reads
                                x2 = x1+readlength
                                n += 1
                                self.flag_ID[read_ID] = 0
                                self.right_group[key] = (x1, x2)
                                if refs-e <= 10000:
                                    if read_ID not in self.ID_right:
                                        self.ID_right[read_ID] = []
                                    self.ID_right[read_ID].append(line)
                                    if read_ID in self.ID_left:
                                        self.both_ID.add(read_ID)
                            else:
                                continue
                        else:
                            if readlength-reade > refs-e:
                                x1 = 1+4*self.max_read + \
                                    refs-e-(readlength-reade)
                                x2 = x1+readlength
                                n += 1
                                self.flag_ID[read_ID] = 1
                                self.right_group[key] = (x1, x2)
                                if refs-e <= 10000:
                                    if read_ID not in self.ID_right:
                                        self.ID_right[read_ID] = []
                                    self.ID_right[read_ID].append(line)
                                    if read_ID in self.ID_left:
                                        self.both_ID.add(read_ID)
                            else:
                                continue
                            # self.right_group[key]=(x1,x2)
                        # else:continue
                    if x1 != 0:
                        if read_ID not in self.ID_content:
                            self.ID_content[read_ID] = []
                        self.ID_content[read_ID].append(line)
                        if read_ID not in self.alignment_position:
                            self.alignment_position[read_ID] = []
                        self.alignment_position[read_ID].append(
                            (refs/unit, refe/unit))
                    else:
                        continue
            # print(len(self.left_group),len(self.right_group))
            left_score = [(k, self.cal_score(self.score_true_values[k]))
                          for k in self.left_group if k in self.score_true_values]
            left_score = sorted(left_score, key=lambda x: x[1], reverse=True)
            left_score_dir = {i[0][0]: i[1] for i in left_score}
            right_score = [(k, self.cal_score(self.score_true_values[k]))
                           for k in self.right_group if k in self.score_true_values]
            right_score = sorted(right_score, key=lambda x: x[1], reverse=True)
            right_score_dir = {i[0][0]: i[1] for i in right_score}
            cross_score = [(k, self.cal_score(self.score_true_values[k]))
                           for k in self.cross_group if k in self.score_true_values]
            cross_score = sorted(cross_score, key=lambda x: x[1], reverse=True)
            cross_score_dir = {i[0][0]: i[1] for i in cross_score}
            n = 0
            y_across = set()
            y_position = 100
            self.left_scores = {}
            self.right_scores = {}
            drawn = set()
            self.cross_scores = {}
            self.cross_position = {}
            for e in cross_score:
                infor = e[0]
                read_ID = infor[0]
                y_position = 99-n
                if read_ID in cross_score_dir:
                    self.cross_scores[read_ID] = cross_score_dir[read_ID]
                x = list(self.cross_group[infor])
                y = [y_position, y_position]
                # self.left_id_position[read_ID]=x[1]
                if y_position not in self.cross_position:
                    self.cross_position[y_position] = read_ID
                if read_ID not in drawn:
                    self.graphicsView.plot(x, y, pen=read_lines)
                    if read_ID not in self.ID_location:
                        self.ID_location[read_ID] = []
                    self.ID_location[read_ID].append(x+y)
                    # self.drawn_ID[read_ID].append(x+y)
                    self.drawn_ID[read_ID] = x+y
                    if read_ID in self.across_ID:
                        y_across.add(y_position)
                    drawn.add(read_ID)
                n += 1
            i = 0
            cross_y = y_position-1
            for e in left_score:
                infor = e[0]
                read_ID = infor[0]
                y_position = cross_y-i
                if read_ID in left_score_dir:
                    self.left_scores[read_ID] = left_score_dir[read_ID]
                x = list(self.left_group[infor])
                y = [y_position, y_position]
                self.left_id_position[read_ID] = x[1]
                if y_position not in self.read_position:
                    self.read_position[y_position] = [read_ID]
                self.graphicsView.plot(x, y, pen=read_lines)
                if read_ID not in self.ID_location:
                    self.ID_location[read_ID] = []
                self.ID_location[read_ID].append(x+y)
                self.drawn_ID[read_ID] = x+y
                i += 1

            j = 0
            for e in right_score:
                y_position = cross_y-j
                infor = e[0]
                read_ID = infor[0]
                if read_ID in right_score_dir:
                    self.right_scores[read_ID] = right_score_dir[read_ID]
                if y_position in y_across:
                    y_position -= 1
                    j += 1
                x = list(self.right_group[infor])
                y = [y_position, y_position]
                if y_position not in self.read_position:
                    self.read_position[y_position] = [0, read_ID]
                else:
                    self.read_position[y_position].append(read_ID)
                self.graphicsView.plot(x, y, pen=read_lines)
                if read_ID not in self.ID_location:
                    self.ID_location[read_ID] = []
                self.ID_location[read_ID].append(x+y)
                self.drawn_ID[read_ID] = x+y
                j += 1
            # if self.is_first:
            #     self.scatter1.scene().sigMouseMoved.connect(self.mouseover2)  # 这两句是获取坐标位置
            #     self.scatter1.scene().sigMouseClicked.connect(self.mouse_clicked2)
            #     pg.SignalProxy(self.scatter1.scene().sigMouseMoved,
            #                    rateLimit=60, slot=self.mouseover2)
            # self.is_first = False
        # elif '_' in gap_infor:#补端粒
        else:
            self.cross_position = {}
            self.unit = unit
            self.max_read = self.read_max*unit
            self.graphicsView.clear()
            x = [self.max_read, 3*self.max_read]
            y = [100, 100]
            gap_region = pg.mkPen(color="#025949", width=4)
            self.scatter1 = self.graphicsView.plot(x, y, pen=gap_region)
            with open(self.map_score) as f:
                f.seek(self.map_score_idx[chrid])
                for line in f:
                    id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                    if id2 != chrid:
                        break
                    k = (id1, id2, dir)
                    v1 = int(v1)
                    v2 = float(v2)
                    v3 = float(v3)
                    v4 = int(v4)
                    v5 = int(v5)  # 后续需要加上v5
                    self.score_true_values[k] = (v1, v2, v3, v4, v5)
            self.left_scores = {}
            self.right_scores = {}
            cr_index = self.cr_idx
            with open(cr_file) as f:
                self.read_position = {}
                self.ID_content = {}
                self.alignment_position = {}
                self.left_id_position = {}
                f.seek(int(cr_index[chrid]))
                content = {}
                n = 0
                yl = 0
                yr = 0
                # xy=[]
                only_ID={}
                for line in f:
                    x1 = 0
                    linelist = line.split()
                    refs = int(linelist[7])*unit
                    refe = int(linelist[8])*unit
                    readlength = int(linelist[1])*unit
                    
                    read_ID = linelist[0]
                    alignment_qua = int(linelist[9])
                    reade = int(linelist[3])*unit
                    reads = int(linelist[2])*unit
                    direction = linelist[4]
                    kmer = float(linelist[-1])
                    refeid = linelist[5]
                    self.ID_length[read_ID] = int(linelist[1])
                    key=(read_ID, refeid, direction)
                    if refeid != chrid:
                        break
                    # left_score = [(k, self.cal_score(self.score_true_values[k]))
                    #       for k in self.left_group if k in self.score_true_values]
                    if direction=='+':
                        if 'left' in gap_infor and reade>refe:
                            x1=self.max_read-(reade-refe);x2=x1+readlength
                            self.left_scores[read_ID]=self.cal_score(self.score_true_values[key])
                            only_ID[read_ID]=[x1,x2]
                            self.flag_ID[read_ID] = 0
                        elif 'right' in gap_infor:
                            chr_length=int(gap_infor.split()[1])*unit
                            c_length=chr_length-refe
                            r_length=readlength-reade
                            self.right_scores[read_ID]=self.cal_score(self.score_true_values[key])
                            if r_length>c_length:
                                x2=3*self.max_read+r_length-c_length;x1=x2-readlength
                                only_ID[read_ID]=[x1,x2]
                                self.flag_ID[read_ID] = 0
                    elif direction=='-':
                        if 'left' in gap_infor and readlength-reade>refs: 
                            x1=self.max_read-(readlength-reade-refs);x2=x1+readlength
                            self.left_scores[read_ID]=self.cal_score(self.score_true_values[key])
                            only_ID[read_ID]=[x1,x2]
                            self.flag_ID[read_ID] = 1
                        elif 'right' in gap_infor:
                            chr_length=int(gap_infor.split()[1])*unit
                            c_length=chr_length-refe
                            self.right_scores[read_ID]=self.cal_score(self.score_true_values[key])
                            if c_length<reads:
                                x2=3*self.max_read+reads-c_length;x1=x2-readlength
                                only_ID[read_ID]=[x1,x2]
                                self.flag_ID[read_ID] = 1
                    if x1!=0:
                        if read_ID not in self.ID_content:self.ID_content[read_ID]=[]
                        self.ID_content[read_ID].append(line)
                for n,content in enumerate(only_ID):
                    y1=y2=99-n
                    y=[y1,y2]
                    self.read_position[y1]=[content]
                    self.graphicsView.plot(only_ID[content], y, pen=read_lines)
                    self.drawn_ID[content] = only_ID[content]+y
        if self.is_first:
            self.scatter1.scene().sigMouseMoved.connect(self.mouseover2)  # 这两句是获取坐标位置
            self.scatter1.scene().sigMouseClicked.connect(self.mouse_clicked2)
            pg.SignalProxy(self.scatter1.scene().sigMouseMoved,
                            rateLimit=60, slot=self.mouseover2)
        self.is_first = False



    def draw_readvsread(self, ID):
        self.score_true_values = {}
        self.ID_location = {}  # 到显示read比read的话，就把收集的染色体部分清空
        self.ID_check = 1  # 记录ID是否是read比read过程中的ID以排除cross中的bug
        self.graphicsView.clear()
        self.ID = ID
        rr_file = self.readvsread
        self.flag = self.flag_ID[ID]
        self.light_list = []
        self.ID_group = {}
        score = []

        y_pos = 100
        n = 0
        unit = 10**-(len(str(self.read_max))-2)
        x_max = self.read_max*unit
        # s, e = self.comboBox_2.currentText().split('-')
        if self.left_start == 0:
            y = [y_pos, y_pos]
            if 'left'  not in self.comboBox_2.currentText():
                x = [1, 1+x_max]    
                gap_region = pg.mkPen(color="#025949", width=4)
                self.graphicsView.plot(x, y, pen=gap_region)
                vLine = pg.InfiniteLine(angle=90, movable=False)
                self.graphicsView.addItem(vLine, ignoreBounds=True)
                vLine.setPos(1+x_max)
            readlength = self.ID_length[ID]*unit
            x = [1+2*x_max, 1+2*x_max+readlength]
            target_read = pg.mkPen(color="#025949", width=4)
            self.scatter1 = self.graphicsView.plot(x, y, pen=target_read)
            self.textItem = pg.TextItem(ID, color="#FF0000")
            self.graphicsView.addItem(self.textItem)
            self.textItem.setPos((x[0]+x[1])*0.5, 110)
        elif self.left_start == 1:
            readlength = self.ID_length[ID]*unit
            x = [1+readlength+x_max, 1+readlength+2*x_max]
            y = [y_pos, y_pos]
            gap_region = pg.mkPen(color="#025949", width=4)
            self.scatter1 = self.graphicsView.plot(x, y, pen=gap_region)
            vLine = pg.InfiniteLine(angle=90, movable=False)
            self.graphicsView.addItem(vLine, ignoreBounds=True)
            vLine.setPos(1+x_max+readlength)
            if 'right'  not in self.comboBox_2.currentText():
                x = [1, 1+readlength]
                target_read = pg.mkPen(color="#025949", width=4)
                self.graphicsView.plot(x, y, pen=target_read)
                self.textItem = pg.TextItem(ID, color="#FF0000")
                self.graphicsView.addItem(self.textItem)
                self.textItem.setPos((x[0]+x[1])*0.5, 110)
        
        read_shown = set()
        n = 0
        color_level = {0: '#FF9D7F', 1: '#FF7E64',
                       2: '#FF5E4A', 3: '#FF3B30', 4: '#E00017'}
        self.readvsread_y = {}
        self.qid_rid = {}
        if ID not in self.reads_ID_content:
            with open(self.ovlp_score) as f:
                for idx in self.ovlp_score_idx[ID]:
                    f.seek(idx)
                    for line in f:
                        id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                        if id1 != ID and id2 != ID:
                            break
                        k = (id1, id2, dir)
                        v1 = int(v1)
                        v2 = float(v2)
                        v3 = float(v3)
                        v4 = int(v4)
                        v5 = int(v5)  # 后续需要加上v5
                        self.score_true_values[k] = (v1, v2, v3, v4, v5)
            self.reads_ID_content[ID] = []
            self.drawn_ID = {}
            
            rr_index = self.rr_idx
            with open(rr_file) as f:
                if ID in rr_index:
                    for lineindex in rr_index[ID]:
                        f.seek(lineindex)
                        for line in f:
                            linelist = line.split()
                            if linelist[0] != ID and linelist[5] != ID:
                                break
                            if linelist[0] == ID:
                                linelist[0:4], linelist[5:9] = linelist[5:9], linelist[0:4]
                            qid = linelist[0]
                            ql = int(linelist[1])*unit
                            qs = int(linelist[2])*unit
                            qe = int(linelist[3])*unit
                            level = int(int(linelist[12])/10)
                            direction = linelist[4]
                            rid = linelist[5]
                            rs = int(linelist[7])*unit
                            re = int(linelist[8])*unit
                            rl = int(linelist[6])*unit
                            if qid not in self.drawn_ID:
                                self.drawn_ID[qid] = []
                            if rid not in self.drawn_ID:
                                self.drawn_ID[rid] = []
                            self.reads_ID_content[ID].append(line)
                            self.ID_length[qid] = int(linelist[1])
                            self.ID_length[rid] = int(linelist[6])
                            if qid not in read_shown and rid not in read_shown:
                                if level > 4:
                                    level = 4
                                read_shown.add(qid)
                                if direction == '+':
                                    tail_length = ql-qe
                                    if self.flag == 0:
                                        x0 = x[0]+rs-qs
                                        self.flag_ID[qid] = 0
                                    else:
                                        x0 = x[0]+rs-tail_length
                                        self.flag_ID[qid] = 1
                                else:
                                    tail_length = ql-qe
                                    if self.flag == 0:
                                        x0 = x[0]+rs-tail_length
                                        self.flag_ID[qid] = 1
                                    else:
                                        x0 = x[0]+rs-qs
                                        self.flag_ID[qid] = 0
                                x1 = x0+ql
                                self.ID_group[(qid, rid, direction)] = [x0, x1]

                    for k in self.ID_group:
                        if k in self.score_true_values:
                            score.append(
                                (k, self.cal_score(self.score_true_values[k])))
                        elif (k[1], k[0], k[2]) in self.score_true_values:
                            score.append(
                                (k, self.cal_score(self.score_true_values[(k[1], k[0], k[2])])))
                    score = sorted(score, key=lambda x: x[1], reverse=True)
                    self.ID_score = {item[0][0]: item[1] for item in score}
                    for item in score:
                        qid = item[0][0]
                        y_pos = 90-n*10
                        read_lines = pg.mkPen(color='#F2B950', width=8)
                        self.readvsread_y[y_pos] = qid  # 以query ID存储y的信息
                        self.qid_rid[y_pos] = 'qid'
                        self.drawn_ID[qid] = self.ID_group[item[0]
                                                           ]+[y_pos, y_pos]
                        self.graphicsView.plot(self.ID_group[item[0]], [
                                               y_pos, y_pos], pen=read_lines)
                        n += 1
                else:
                    content = 'No alignment detected for the ID, please select another ID for gap filling.'
                    w = InfoBar.warning(title='Warning: ', content=content, isClosable=True,
                                        duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                    w.setStyleSheet(
                        '''QFrame{font-size: 18px;background-color:#fef4ce}''')
                    w.show()
                    if self.add_pathway == 1:
                        self.add_pathway -= 1
                        self.show_potentials()
                        self.treeView.removeRow(self.add_pathway)
                    else:
                        self.treeView.removeRow(self.add_pathway-1)
                        self.add_pathway -= 1
                        item = self.treeView.item(self.add_pathway-1, 0)
                        ID = item.text()
                        self.draw_readvsread(ID)

        else:
            with open(self.ovlp_score) as f:
                for idx in self.ovlp_score_idx[ID]:
                    f.seek(idx)
                    for line in f:
                        id1, id2, dir, v1, v2, v3, v4, v5 = line.split()  # ,v5后续需要加上v5
                        if id1 != ID and id2 != ID:
                            break
                        k = (id1, id2, dir)
                        v1 = int(v1)
                        v2 = float(v2)
                        v3 = float(v3)
                        v4 = int(v4)
                        v5 = int(v5)  # 后续需要加上v5
                        self.score_true_values[k] = (v1, v2, v3, v4, v5)
            if ID in self.reads_ID_content:
                f = self.reads_ID_content[ID]
                for line in f:
                    linelist = line.split()
                    if linelist[0] != ID and linelist[5] != ID:
                        break
                    if linelist[0] == ID:
                        linelist[0:4], linelist[5:9] = linelist[5:9], linelist[0:4]
                    qid = linelist[0]
                    ql = int(linelist[1])*unit
                    qs = int(linelist[2])*unit
                    qe = int(linelist[3])*unit
                    level = int(int(linelist[12])/10)
                    direction = linelist[4]
                    rid = linelist[5]
                    rs = int(linelist[7])*unit
                    rl = int(linelist[6])*unit
                    re = int(linelist[8])*unit
                    tail_length = ql-qe
                    self.ID_length[qid] = int(linelist[1])
                    self.ID_length[rid] = int(linelist[6])
                    if qid not in read_shown and rid not in read_shown:
                        # if level>4:level=4
                        # read_lines=pg.mkPen(color=color_level[level], width=8)
                        read_shown.add(qid)
                        if direction == '+':
                            tail_length = ql-qe
                            if self.flag == 0:
                                x0 = x[0]+rs-qs
                                self.flag_ID[qid] = 0
                            else:
                                x0 = x[0]+rs-tail_length
                                self.flag_ID[qid] = 1
                        else:
                            if self.flag == 0:
                                x0 = x[0]+rs-tail_length
                                self.flag_ID[qid] = 1
                            else:
                                x0 = x[0]+rs-qs
                                self.flag_ID[qid] = 0
                        x1 = x0+ql

                        self.ID_group[(qid, rid, direction)] = [x0, x1]
                for k in self.ID_group:
                    if k in self.score_true_values:
                        score.append(
                            (k, self.cal_score(self.score_true_values[k])))
                    elif (k[1], k[0], k[2]) in self.score_true_values:
                        score.append(
                            (k, self.cal_score(self.score_true_values[(k[1], k[0], k[2])])))
                score = sorted(score, key=lambda x: x[1], reverse=True)
                self.ID_score = {item[0][0]: item[1] for item in score}
                read_lines = pg.mkPen(color='#F2B950', width=8)
                for item in score:
                    qid = item[0][0]
                    y_pos = 90-n*10
                    # read_lines = pg.mkPen(color='#F2B950', width=8)
                    self.readvsread_y[y_pos] = qid  # 以query ID存储y的信息
                    self.qid_rid[y_pos] = 'qid'
                    self.drawn_ID[qid] = self.ID_group[item[0]]+[y_pos, y_pos]
                    self.graphicsView.plot(self.ID_group[item[0]], [
                                           y_pos, y_pos], pen=read_lines)
                    n += 1
            else:
                content = 'No alignment detected for the ID, please select another ID for gap filling.'
                w = InfoBar.warning(title='Warning: ', content=content, isClosable=True,
                                    duration=20000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                w.setStyleSheet(
                    '''QFrame{font-size: 18px;background-color:#fef4ce}''')
                w.show()
                if self.add_pathway == 1:
                    self.add_pathway -= 1
                    self.show_potentials()
                    self.treeView.removeRow(self.add_pathway)
                else:
                    self.treeView.removeRow(self.add_pathway-1)
                    self.add_pathway -= 1
                    item = self.treeView.item(self.add_pathway-1, 0)
                    ID = item.text()
                    self.draw_readvsread(ID)

    def changecolor(self, ids, color):
        if ids in self.ID_location:  # 实时改变颜色，但需要调整
            for i in self.ID_location[ids]:
                x1, x2, y1, y2 = i
                read_lines = pg.mkPen(color=color, width=8)
                self.graphicsView.plot([x1, x2], [y1, y2], pen=read_lines)

    def mouseover2(self, pos):
        act_pos = self.scatter1.mapFromScene(pos)
        if type(act_pos) != QtCore.QPointF:
            return
        self.new_point_y2 = act_pos.y()
        self.new_point_x2 = act_pos.x()
        if '_' not in self.comboBox_2.currentText():
            self.graphicsView.addItem(self.vLine, ignoreBounds=True)
            self.graphicsView.addItem(self.hLine, ignoreBounds=True)
            self.vLine.setPos(self.new_point_x2)
            self.hLine.setPos(self.new_point_y2)
        y_position = round(self.new_point_y2, 0)
        if y_position in self.readvsread_y:
            self.left_scores = {}
            self.right_scores = {}
            self.cross_position = {}
            id = self.readvsread_y[y_position]
            score = self.ID_score[id]
            self.lineEdit_2.setText(
                'read_ID:{}  Confidence score={}'.format(id, score))
        else:
            if y_position in self.read_position:
                ids = self.read_position[y_position]
                if len(ids) == 2:
                    id1, id2 = ids
                    if self.new_point_x2 <= self.x_thre:
                        if id1 != 0 and id1 in self.left_scores:
                            score = self.left_scores[id1]
                            geneid = id1
                            self.lineEdit_2.setText(
                                'read_ID:{}  Confidence score={}'.format(geneid, score))

                    else:
                        if id2 in self.right_scores:
                            score = self.right_scores[id2]
                            geneid = id2
                            self.lineEdit_2.setText(
                                'read_ID:{}  Confidence score={}'.format(geneid, score))
                else:
                    geneid = ids[0]
                    score = self.left_scores[geneid]
                    self.lineEdit_2.setText(
                                'read_ID:{}  Confidence score={}'.format(geneid, score))
            elif y_position in self.cross_position:
                read_id = self.cross_position[y_position]
                if read_id in self.cross_scores:
                    score = self.cross_scores[read_id]
                    self.lineEdit_2.setText(
                        'read_ID:{}  Confidence score={}'.format(read_id, score))

    def clear_svg(self):
        item_list = list(range(self.mdi.count()))
        item_list.reverse()  # 倒序删除，避免影响布局顺序
        for i in item_list:
            item = self.mdi.itemAt(i)
            self.mdi.removeItem(item)
            if item.widget():
                item.widget().deleteLater()

    def cross_id_fix(self, path):
        fa_file = self.read_seq
        t_dir = self.path_to_sequence(path, fa_file)
        chrid = self.comboBox.currentText()
        if chrid not in self.merge_result:
            self.merge_result[chrid] = []
        self.merge_result[chrid].append(t_dir)
        InfoBar.success(
            title='Note !',
            content='You have successfully filled this gap, and you can choose the next gap.',
            orient=Qt.Horizontal,    # vertical layout
            isClosable=True,
            position=InfoBarPosition.TOP_LEFT,
            duration=4000,
            parent=self.graphicsView
        )

    def mouse_clicked2(self):
        self.treeView_3.clearContents()
        self.treeView_3.clicked.disconnect()
        self.treeView_3.clicked.connect(self.show_highlight)
        if self.add_pathway < 1:
            self.temp_multi_alignment = {}
            self.dir_y_position = {}  # 收集每一轮的坐标
            y_position = round(self.new_point_y2, 0)
            x_position = round(self.new_point_x2, 0)
            if y_position in self.read_position or y_position in self.cross_position:
                if y_position in self.read_position:
                    ids = self.read_position[y_position]
                    if len(ids) == 2:
                        id1, id2 = ids
                        if id1 != 0:
                            x_id1 = self.left_id_position[id1]
                            if x_position <= x_id1:
                                self.read_ids = id1
                            else:
                                self.read_ids = id2
                        else:
                            self.read_ids = id2
                        if self.add_pathway < 1:
                            if self.read_ids in self.ID_right:
                                self.right_position = 1
                            else:
                                self.right_position = 0
                    else:
                        self.read_ids = ids[0]
                if y_position in self.cross_position:
                    self.read_ids = self.cross_position[y_position]
                    # if self.read_ids not in self.across_ID:
                alignments = self.ID_content[self.read_ids]
                self.target_infor = alignments
                self.draw_read(alignments, './draw_gap.svg')
                # self.draw_read2(alignments,'./draw_gap.svg')
                self.mdi2.setStyleSheet(
                    '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
                self.clear_svg()
                self.svg_widget = QSvgWidget()
                self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
                self.svg_widget.customContextMenuRequested.connect(
                    self.right_menu)
                self.svg_widget.load('./draw_gap.svg')
                self.mdi.addWidget(self.svg_widget)
                # self.temp_multi_alignment={index:line for index,line in enumerate(self.target_infor)}
                if self.read_ids in self.drawn_ID:
                    position = self.drawn_ID[self.read_ids]
                    x = position[:2]
                    y = position[2:]
                    read_lines = pg.mkPen(color='#F2784B', width=8)
                    self.graphicsView.plot(x, y, pen=read_lines)
                    if self.light_list == []:
                        self.light_list = position
                    else:
                        x = self.light_list[:2]
                        y = self.light_list[2:]
                        read_lines = pg.mkPen(color='#B4AA92', width=8)
                        self.graphicsView.plot(x, y, pen=read_lines)
                        self.light_list = position
                    if self.new_point_x2 < 1+self.max_read*2:
                        self.target_set = self.ID_right
                    else:
                        self.target_set = self.ID_left
                if self.read_ids in self.across_ID and self.ID_check == 0:
                    # self.treeView.setItem(self.add_pathway,0,QTableWidgetItem(self.read_ids))
                    path = []
                    gap_range = self.comboBox_2.currentText().split('-')
                    s, e = int(gap_range[0]), int(gap_range[1])
                    for line in alignments:
                        linelist = line.split()
                        refs = int(linelist[7])
                        refe = int(linelist[8])
                        readlength = int(linelist[1])
                        read_ID = linelist[0]
                        reade = int(linelist[3])
                        reads = int(linelist[2])
                        direction = linelist[4]
                        refeid = linelist[5]
                        if refs <= s < e <= refe:
                            path = [[read_ID, readlength,
                                    (refs, refe), (reads, reade), direction]]
                    if self.Congratulations == 0:
                        content = 'This ID can span the gap, and you can click the "fix the gap" button on the right to fill the gap'
                        w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                            duration=10000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)
                        self.fix_gap_button = PushButton('fix the gap')
                        self.fix_gap_button.clicked.connect(
                            lambda: self.cross_id_fix(path=path))
                        # self.fix_gap_button.setFixedSize(100, 50)  # 设置按钮大小为 100x50
                        # self.fix_gap_button.setStyleSheet("background-color: #ffffff; color: #000000;")  # 设置按钮的背景色和文字颜色
                        w.addWidget(self.fix_gap_button)
                        self.Congratulations += 1
                        self.time = time.time()
                        w.show()  # 需不需要写show需要进一步验证
                    elif time.time()-self.time >= 2:
                        content = 'This ID can span the gap, and you can click the "fix the gap" button on the right to fill the gap'
                        w = InfoBar.success(title='Congratulations!', content=content, isClosable=True,
                                            duration=10000, position=InfoBarPosition.BOTTOM, parent=self.graphicsView)

                        self.fix_gap_button = PushButton('fix the gap')
                        # self.fix_gap_button.setFixedSize(100, 50)  # 设置按钮大小为 100x50
                        # self.fix_gap_button.setStyleSheet("background-color: #ffffff; color: #000000;")  # 设置按钮的背景色和文字颜色
                        self.fix_gap_button.clicked.connect(
                            lambda: self.cross_id_fix(path=path))
                        w.addWidget(self.fix_gap_button)
                        self.time = time.time()
                        w.show()  # 需不需要写show需要进一步验证
        else:
            self.passed = False
            self.temp_multi_alignment = {}
            self.target_id = ''
            y_position = round(self.new_point_y2/10, 0)*10
            if y_position in self.readvsread_y:
                self.read_ids = self.readvsread_y[y_position]
                if self.add_pathway < 1:
                    if self.read_ids in self.ID_right:
                        self.right_position = 1
                    else:
                        self.right_position = 0
                alignments = self.reads_ID_content[self.ID]
                alignment = [
                    line for line in alignments if self.read_ids+'\t' in line]
                if y_position in self.qid_rid:
                    self.target_id = self.qid_rid[y_position]
                self.target_infor = alignment
                self.draw_read2(alignment, './draw_readvsread.svg',
                                target_id=self.target_id)
                self.mdi2.setStyleSheet(
                    '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
                self.clear_svg()
                self.svg_widget = QSvgWidget()
                self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
                self.svg_widget.customContextMenuRequested.connect(
                    self.right_menu2)
                self.svg_widget.load('./draw_readvsread.svg')
                self.mdi.addWidget(self.svg_widget)
                if self.read_ids in self.drawn_ID:
                    position = self.drawn_ID[self.read_ids]
                    x = position[:2]
                    y = position[2:]
                    read_lines = pg.mkPen(color='#F2784B', width=8)
                    self.graphicsView.plot(x, y, pen=read_lines)
                    if self.light_list == []:
                        self.light_list = position
                    else:
                        x = self.light_list[:2]
                        y = self.light_list[2:]
                        read_lines = pg.mkPen(color='#B4AA92', width=8)
                        self.graphicsView.plot(x, y, pen=read_lines)
                        self.light_list = position

    def draw_read(self, content, name, target=None):
        # content=list(set(content))
        self.content = content
        dir_y_position = {}
        lines = ""
        IDs = ""
        bezier = ""
        read_num = 0
        recs = ""
        line_format = '  <line x1="{}" y1="{}" x2="{}" y2="{}" style="stroke:#025949;stroke-width:1"/>\n'
        read_format = '  <line x1="{}" y1="{}" x2="{}" y2="{}" style="stroke:{};stroke-width:1"/>\n'
        score_format = '  <line x1="{}" y1="{}" x2="{}" y2="{}" style="stroke:#0C660E;stroke-width:1"/>\n'
        multip = '  <polygon points="{},10 {},10 {},{} {},{}" fill="{}" opacity=".5" />\n'
        ID = '  <text x="{}" y="{}" text-anchor="middle" fill="black" font-size="1" font-weight="bold" font-family="Times New Roman">{}</text>\n'
        # ID='  <text x="{}" y="{}" lengthAdjust="spacingAndGlyphs" fill="black" font-size="1" font-family="Times New Roman">{}</text>\n'
        
        # gap_range=['15000001', '15000501']
        se=self.comboBox_2.currentText()
        if '-' in se:
            svgwidth = 2+3*self.max_read
            line1 = line_format.format(1, 10, 1+self.max_read, 10)
            line2 = line_format.format(
                1+self.max_read*2, 10, 1+self.max_read*3, 10)
            lines += line1
            lines += line2
            gap_range = se.split('-')
            s = int(gap_range[0])*self.unit
            e = int(gap_range[1])*self.unit
        elif 'left' in se:
            svgwidth = 2+5*self.max_read
            #  line1 = line_format.format(1, 10, 1+self.max_read, 10)
            line2 = line_format.format(1+self.max_read*2, 10, 1+self.max_read*5, 10)
            # lines += line1
            lines += line2
            s=-1
            e=0
        elif 'right' in se:
            svgwidth = 2+1*self.max_read
            line1 = line_format.format(1, 10, 1+self.max_read, 10)
            # line2 = line_format.format(                1+self.max_read, 10, 1+self.max_read*2, 10)
            lines += line1
            # lines += line2
            s=-1
            e=0
            length=int(content[0].split()[6])*self.unit
            s=length
            e=1000000
        position = set()
        llist_read = []
        llist_ref = []
        rlist_read = []
        rlist_ref = []
        for line in content:
            linelist = line.split()
            refs = int(linelist[7])*self.unit
            refe = int(linelist[8])*self.unit
            readlength = int(linelist[1])*self.unit
            read_ID = linelist[0]
            alignment_qua = int(linelist[9])
            reade = int(linelist[3])*self.unit
            reads = int(linelist[2])*self.unit
            direction = linelist[4]
            kmer = linelist[-1]
            mn = linelist[9]
            al = linelist[10]
            mapq = linelist[11]
            refid = linelist[5]
            ref_length = int(linelist[6])*self.unit
            if refs <= s < e <= refe:
                position.add('c')
            elif s >= refe:
                position.add('l')
            elif e <= refs:
                position.add('r')
            rlist_ref.append(refe)
            llist_ref.append(refs)
            llist_read.append(reads)
            rlist_read.append(reade)
        x1 = 0
        # s,e=g1*self.unit,g2*self.unit
        if len(position) >= 2:
            refs = min(llist_ref)
            reads = min(rlist_read)
            refe = max(rlist_ref)
            reade = min(rlist_read)
            x1 = (1+self.max_read)-(s-refs-reads)
            x2 = (1+2*self.max_read)+(refe-e)+(readlength-reade)
        else:
            if 'l' in position:
                refe = max(rlist_ref)
                reade = min(rlist_read)
                x2 = 1+self.max_read+(readlength-reade)-(s-refe)
                x1 = x2-readlength
            elif 'r' in position:
                x1 = 1+self.max_read*2-(max(llist_read)-(min(llist_ref)-e))
                x2 = x1+readlength
            else:
                refs = min(llist_ref)
                reads = min(rlist_read)
                refe = max(rlist_ref)
                reade = min(rlist_read)
                x1 = (1+self.max_read)-(s-refs-reads)
                x2 = (1+2*self.max_read)+(refe-e)+(readlength-reade)
        x_draw_length = x2-x1
        if target == None:
            self.treeView_3.setRowCount(len(content))
        # if target!=None: content.append(target)
        lines += read_format.format(x1, 20, x2, 20, '#F2B950')
        for index, line in enumerate(content):
            # self.temp_multi_alignment[index]=line
            linelist = line.split()
            refs = int(linelist[7])*self.unit
            refe = int(linelist[8])*self.unit
            readlength = int(linelist[1])*self.unit
            read_ID = linelist[0]
            alignment_qua = int(linelist[9])
            reade = int(linelist[3])*self.unit
            reads = int(linelist[2])*self.unit
            direction = linelist[4]
            kmer = linelist[-1]
            mn = linelist[9]
            al = linelist[10]
            mapq = linelist[11]
            refid = linelist[5]
            ref_length = int(linelist[6])*self.unit
            k = (read_ID, refid, direction)
            if target == None:
                for i, c in enumerate([read_ID, mn, al, mapq, kmer, linelist[1]]):
                    item = QTableWidgetItem(c)
                    item.setTextAlignment(Qt.AlignCenter)
                    self.treeView_3.setItem(index, i, item)
                # self.treeView_3.resizeColumnsToContents()
            if 0 <= alignment_qua < 20:
                level = 3
            elif 20 <= alignment_qua < 40:
                level = 2
            elif 40 <= alignment_qua:
                level = 1
            # if len(position)>=2:
            #     x1=(1+max_read)-(s-refs)-reads;x2=(1+2*max_read)+(refe-e)+(readlength-reade)
            readsp = x1+int((reads/readlength)*x_draw_length)
            readep = x1+int((reade/readlength)*x_draw_length)
            if direction == '-':
                readsp = x2+x1-readep
                readep = x2+x1-(x1+int((reads/readlength)*x_draw_length))
            length_difference = readep-readsp
            if length_difference < 1:
                length_difference = 1
                readsp = readep-1
                if readsp < x1:
                    readsp = x1
                    readep = readsp+1
            if refe <= s:
                refsp = self.max_read-s+refs
                refep = refsp+length_difference  # refep=self.max_read-s+refe
                if refep > 1+self.max_read:
                    refsp = refsp-(refep-1-self.max_read)
                    refep = 1+self.max_read
            elif refs >= e:
                refsp = 1+2*self.max_read+refs-e
                refep = refsp+length_difference  # refep=1+2*self.max_read+refe-e
            elif refs <= s < e <= refe:
                refsp = self.max_read-s+refs
                refep = 1+2*self.max_read+refe-e  # ;readsp=refsp;readep=refep

            if x1 != 0:

                if line == target:
                    # read_num=dir_y_position[line]
                    multip = '  <polygon points="{},10 {},10 {},{} {},{}" fill="{}"/>\n'
                    bezier += multip.format(refsp, refep,
                                            readep, 20, readsp, 20, '#ECE314')
                else:
                    multip = '  <polygon points="{},10 {},10 {},{} {},{}" fill="{}" opacity=".5" />\n'
                    bezier += multip.format(refsp, refep,
                                            readep, 20, readsp, 20, '#C1C6C7')

                read_num += 1
        IDs += ID.format((x1+x2)/2, 22, read_ID)
        for i, n in enumerate(['CS', 'PLA', 'PNA', 'TLNA', 'MBNNA']):
            IDs += ID.format(8*i+3, 29, n)
        if k in self.score_true_values:
            for i, j in enumerate(self.score_true_values[k]):
                if i == 0:
                    j = self.t1*j
                if i == 3:
                    j = self.t4*j
                if i == 4:
                    j = self.t5*j
                if j > 2:
                    j = 2
                infor = score_format.format(8*i+3, 28, 8*i+3, 28-j*4)
                recs += infor
                IDs += ID.format(8*i+3, 27-j*4, self.score_true_values[k][i])
        with open(name, "w") as f:
            # global svgwidth, svghight
            # svgwidth = 2+3*self.max_read
            svghight = 30
            file_title = '<svg width="{}mm" height="{}mm" viewBox="0 0 {} {}" preserveAspectRatio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg" version="1.1">\n'.format(
                svgwidth*3, svghight*3, svgwidth, svghight)
            end = '</svg>'  # 上面这句在更改单位的时候需要搭配viewBOX才能真正调整大小，且大小应该小于等于图片大小，如上
            f.write(file_title+bezier+lines+IDs+recs+end)

    def draw_read2(self, content, name, target=None, target_id=None):
        self.content = content
        # if y_position in self.qid_rid:
        #     target_id=self.qid_rid[y_position]
        lines = ""
        IDs = ""
        bezier = ""
        target_aln = ""
        recs = ""
        line_format = '  <line x1="{}" y1="{}" x2="{}" y2="{}" style="stroke:{};stroke-width:1"/>\n'
        score_format = '  <line x1="{}" y1="{}" x2="{}" y2="{}" style="stroke:#0C660E;stroke-width:1"/>\n'
        multip = '  <polygon points="{},{} {},{} {},{} {},{}" fill="{}" opacity=".3" />\n'
        ID = '  <text x="{}" y="{}" style="text-anchor:start" fill="red" font-size="0.5" font-family="Times New Roman">{}</text>\n'
        ID4 = '  <text x="{}" y="{}" style="text-anchor:start" fill="white" font-size="0.5" font-family="Times New Roman">{}</text>\n'
        ID3 = '  <text x="{}" y="{}" text-anchor="middle" fill="black" font-size="1" font-weight="bold" font-family="Times New Roman">{}</text>\n'
        ID5 = '  <text x="{}" y="{}" style="text-anchor:start" fill="white" font-size="0.5" font-family="Times New Roman">{}</text>\n'
        end_list = []
        start_list = []
        infor = content[0]
        infor_list = infor.split()
        if infor_list[0] == self.current_ID:
            infor_list[0:4], infor_list[5:9] = infor_list[5:9], infor_list[0:4]
        ID1 = infor_list[0]
        ID2 = infor_list[5]
        length2 = len(infor_list[6])
        unit = 10**(-(length2-2))
        direction = infor_list[4]
        q_start = int(infor_list[2])*unit
        different = (int(infor_list[1])-int(infor_list[3]))*unit
        ref_end = 10+int(infor_list[6])*unit  # ref_start=10
        # ref_align_start=10+int(infor_list[7])*unit
        line1 = line_format.format(10, 15, ref_end, 15, '#014040')
        lines += line1
        query_list = []
        for line in content:
            linelist = line.split()
            if linelist[0] == self.current_ID:
                linelist[0:4], linelist[5:9] = linelist[5:9], linelist[0:4]
            ref_align_start = int(linelist[7])*unit
            q_start = int(linelist[2])*unit
            qlength = int(linelist[1])*unit
            if self.alignment_p == '-':
                q_start = qlength-q_start
            query_list.append(10+ref_align_start-q_start)
        q_start = max(min(query_list), 2)
        if 'left' in self.comboBox_2.currentText():
            self.right_position = 1 
        if self.right_position == 0:
            if q_start < 15:
                q_start = 15
            line1 = line_format.format(0, 15, 9.9, 15, '#014040')
            lines += line1
            line1 = line_format.format(9.9, 15, 10, 15, '#FF0000')
            lines += line1
            IDs += ID5.format(5.25, 15, 'Chr')
        else:
            if q_start > ref_end:
                q_start = ref_end
            line1 = line_format.format(
                ref_end+0.1, 15, ref_end+10.1, 15, '#014040')
            lines += line1
            line1 = line_format.format(ref_end, 15, ref_end+0.1, 15, '#FF0000')
            lines += line1
            IDs += ID5.format(ref_end+5.1, 15, 'Chr')
        q_end_position = q_start+qlength
        IDs += ID4.format(10, 15, ID2)
        end_list.append(ref_end)
        start_list.append(10)
        position = {}
        ID_position = set()
        alignment_pos = set()
        if target == None:
            self.treeView_3.setRowCount(len(content))
        for index, line in enumerate(content):
            # self.temp_multi_alignment[index]=line
            linelist = line.split()
            if linelist[0] == self.current_ID:
                linelist[0:4], linelist[5:9] = linelist[5:9], linelist[0:4]
            direction = linelist[4]
            ref_align_start = int(linelist[7])*unit
            q_start_alignment = int(linelist[2])*unit
            different = (int(linelist[1])-int(linelist[3]))*unit
            read_ID = linelist[0]
            qlength = int(linelist[1])*unit
            q1 = int(linelist[2])*unit
            q2 = int(linelist[3])*unit
            r1 = int(linelist[7])*unit
            r_end = int(linelist[8])*unit
            rlength = int(linelist[6])*unit
            mn = linelist[9]
            al = linelist[10]
            mapq = linelist[11]
            kmer = linelist[12]
            if read_ID > linelist[5]:
                k = (linelist[5], read_ID, direction)
            else:
                k = (read_ID, linelist[5], direction)
            # if target_id=='rid':read_ID=linelist[5]
            if target == None:
                for i, c in enumerate([read_ID, mn, al, mapq, kmer, linelist[1]]):
                    item = QTableWidgetItem(c)
                    item.setTextAlignment(Qt.AlignCenter)
                    self.treeView_3.setItem(index, i, item)
                # self.treeView_3.resizeColumnsToContents()
            if self.alignment_p == '-':
                if direction == '+':
                    q1 = qlength-q2
                    q2 = qlength-q_start_alignment
                    r2 = rlength-r1
                    r1 = rlength-r_end

                    if line == target:
                        target_aln += multip.format(q_start+q1, 5,
                                                    q_start+q2, 5, 10+r2, 15, 10+r1, 15, '#ECE314')
                    else:
                        bezier += multip.format(q_start+q1, 5, q_start+q2,
                                                5, 10+r2, 15, 10+r1, 15, '#C1C6C7')
                    line2 = line_format.format(
                        q_start, 5, q_end_position, 5, '#F2B950')
                else:
                    r2 = rlength-r1
                    r1 = rlength-r_end
                    if line == target:
                        target_aln += multip.format(q_start+q1, 25,
                                                    q_start+q2, 25, 10+r2, 15, 10+r1, 15, '#ECE314')
                    else:
                        bezier += multip.format(q_start+q1, 25, q_start+q2,
                                                25, 10+r2, 15, 10+r1, 15, '#C1C6C7')
                    line2 = line_format.format(
                        q_start, 25, q_end_position, 25, '#F2B950')
            elif self.alignment_p == '+':
                if direction == '+':
                    if line == target:
                        target_aln += multip.format(q_start+q1, 5, q_start+q2,
                                                    5, 10+r_end, 15, 10+r1, 15, '#ECE314')
                    else:
                        bezier += multip.format(q_start+q1, 5, q_start+q2,
                                                5, 10+r_end, 15, 10+r1, 15, '#C1C6C7')
                    line2 = line_format.format(
                        q_start, 5, q_end_position, 5, '#F2B950')
                else:
                    q1 = qlength-q2
                    q2 = qlength-q_start_alignment
                    if line == target:
                        target_aln += multip.format(
                            q_start+q1, 25, q_start+q2, 25, 10+r_end, 15, 10+r1, 15, '#ECE314')
                    else:
                        bezier += multip.format(q_start+q1, 25, q_start+q2,
                                                25, 10+r_end, 15, 10+r1, 15, '#C1C6C7')
                    line2 = line_format.format(
                        q_start, 25, q_end_position, 25, '#F2B950')
            lines += line2
            end_list.append(q_end_position)
            for i, n in enumerate(['CS', 'PLA', 'PNA', 'TLNA', 'MBNNA']):
                IDs += ID3.format(8*i+3, 29, n)
            if k in self.score_true_values:
                for i, j in enumerate(self.score_true_values[k]):
                    if i == 0:
                        j = self.t1*j
                    if i == 3:
                        j = self.t4*j
                    if i == 4:
                        j = self.t5*j
                    if j > 2:
                        j = 2
                    infor = score_format.format(8*i+3, 28, 8*i+3, 28-j*4)
                    recs += infor
                    IDs += ID3.format(8*i+3, 27-j*4,
                                      self.score_true_values[k][i])
        bezier += target_aln

        with open(name, "w") as f:
            svghight = 30
            if self.right_position == 0:
                svgwidth = 16+max(end_list)
            else:
                svgwidth = 10.2+ref_end
            file_title = '<svg width="{}mm" height="{}mm" viewBox="0 0 {} {}" preserveAspectRatio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg" version="1.1">\n'.format(
                svgwidth*3, svghight*3, svgwidth, svghight)
            end = '</svg>'  # 上面这句在更改单位的时候需要搭配viewBOX才能真正调整大小，且大小应该小于等于图片大小，如上
            f.write(file_title+bezier+lines+IDs+recs+end)

    def show_chr_read(self):
        if self.path_order > 0:
            self.show_candidate_infor()
        if self.add_candidate >0:
            read_ID = self.treeView_2.currentItem().text()
            if self.add_pathway < 1:
                alignments = self.candidate_infor[read_ID]
                self.draw_read(alignments, './candidate.svg')
            elif self.add_pathway >= 1:
                alignments = self.candidate_infor[read_ID]
                self.draw_read2(alignments, './candidate.svg')
            self.showwindow()

    def show_highlight(self):
        index = self.treeView_3.currentIndex()
        if index.isValid():
            row = index.row()
            # print(self.temp_multi_alignment)
            target = self.content[row]
            # print(target)
            # print(row)
            content = self.content
            if self.add_pathway < 1 or self.passed:
                self.draw_read(content, './draw_gap.svg', target=target)
                self.mdi2.setStyleSheet(
                    '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
                self.clear_svg()
                self.svg_widget = QSvgWidget()
                self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
                self.svg_widget.customContextMenuRequested.connect(
                    self.right_menu)
                self.svg_widget.load('./draw_gap.svg')
                self.mdi.addWidget(self.svg_widget)
            else:
                self.draw_read2(content, './draw_readvsread.svg',
                                target=target)
                self.mdi2.setStyleSheet(
                    '''QStackedWidget{background-color: rgb(255, 255, 255)}''')
                self.clear_svg()
                self.svg_widget = QSvgWidget()
                self.svg_widget.setContextMenuPolicy(Qt.CustomContextMenu)
                self.svg_widget.customContextMenuRequested.connect(
                    self.right_menu2)
                self.svg_widget.load('./draw_readvsread.svg')
                self.mdi.addWidget(self.svg_widget)

    def reloading(self):
        a = InfoBar.warning(
            title='tip',
            content="Please wait patiently while loading the corresponding files.",
            orient=Qt.Horizontal,
            isClosable=False,   # disable close button
            position=InfoBarPosition.TOP_LEFT,
            duration=-1,
            parent=self.graphicsView
        )
        # QApplication.processEvents()
        self.return_to_previ()

        a.close()

        # InfoBar.success(
        #     title='finished',
        #     content='The files have been loaded completely. Now you can select "chr IDs" for further analysis.',
        #     orient=Qt.Horizontal,    # vertical layout
        #     isClosable=True,
        #     position=InfoBarPosition.TOP_LEFT,
        #     duration=4000,
        #     parent=self.graphicsView
        # )

    def return_to_previ(self):
        self.passed = False
        if self.pushButton_11.isChecked and self.add_pathway >0:
            self.pushButton_11.setText('        loading...')
            self.pushButton_11.repaint()
            self.clear_content()
            if len(self.pathway_added) > 0:
                self.pathway_added.remove(self.current_ID)
            else:
                a = InfoBar.warning(
                    title='warning',
                    content="The pathway is empty",
                    orient=Qt.Horizontal,
                    isClosable=False,   # disable close button
                    position=InfoBarPosition.TOP_LEFT,
                    duration=1000,
                    parent=self.graphicsView
                )
                a.close()
            del self.pathway_id_list[-1]
            if len(self.pathway_id_list) == 0:
                self.alignment_p, self.current_ID = "", ""
            else:
                self.alignment_p, self.current_ID = self.pathway_id_list[-1]
            # print(self.pathway_id_list)
            # print(self.alignment_p,self.current_ID)

            if self.add_pathway == 1:
                self.add_pathway -= 1
                self.show_potentials()
                self.treeView.removeRow(self.add_pathway)
            else:
                item = self.treeView.item(self.add_pathway-1, 0)
                ID = item.text()
                if ID in self.join_path_infor:
                    del self.join_path_infor[ID]
                    self.target_list.remove(ID)
                self.treeView.removeRow(self.add_pathway-1)
                self.treeView.removeRow(self.add_pathway)
                self.add_pathway -= 1
                item = self.treeView.item(self.add_pathway-1, 0)
                ID = item.text()
                self.draw_readvsread(ID)
        self.pushButton_11.setText('        go back')
        # self.pathway_added=set()
        self.pushButton_11.repaint()


class MyTableWidget(QTableWidget):
    update_table_tooltip_signal = pyqtSignal(object)

    def __init__(self):
        super(MyTableWidget, self).__init__()
        self.ini_table()

    def ini_table(self):
        QTableWidget.resizeColumnsToContents(self)
        QTableWidget.resizeRowsToContents(self)
        # self.setSelectionMode(QAbstractItemView.NoSelection)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSelectionBehavior(QTableWidget.SelectRows)
        # self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        # self.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        # self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)

        self.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.horizontalHeader().setVisible(False)
        self.verticalHeader().setVisible(False)
        self.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.vertical_scrollbar = QScrollBar()
        self.horizon_scrollbar = QScrollBar()
        self.vertical_scrollbar.valueChanged.connect(
            partial(self.scollbar_change_slot, "vertical"))
        self.horizon_scrollbar.valueChanged.connect(
            partial(self.scollbar_change_slot, "horizon"))
        self.setVerticalScrollBar(self.vertical_scrollbar)
        self.setHorizontalScrollBar(self.horizon_scrollbar)
        self.init_row = 0
        self.init_col = 0
        self.tool_tip = ""
        self.update_table_tooltip_signal.connect(
            self.update_table_tooltip_slot)
        self.title_row_height = 0

    # 为TableWidget安装事件过滤器
    def install_eventFilter(self):
        self.installEventFilter(self)
        self.setMouseTracking(True)

    # 改变滚动条时重置当前页面的初始行和列
    def scollbar_change_slot(self, type):
        if type == "vertical":
            value = self.verticalScrollBar().value()
            self.init_row = value
        else:
            value = self.horizontalScrollBar().value()
            self.init_col = value

    # 通过计算坐标确定当前位置所属单元格
    def update_table_tooltip_slot(self, posit):
        self.tool_tip = ""
        self.mouse_x = posit.x()
        self.mouse_y = posit.y()
        self.row_height = self.title_row_height  # 累计行高,初始值为列标题行高
        for r in range(self.rowCount()):
            current_row_height = self.rowHeight(r)
            self.col_width = 0  # 累计列宽
            if self.row_height <= self.mouse_y <= self.row_height + current_row_height:
                for c in range(self.columnCount()):
                    current_col_width = self.columnWidth(c)
                    if self.col_width <= self.mouse_x <= self.col_width + current_col_width:
                        r = self.init_row + r
                        c = self.init_col + c
                        item = self.item(r, c)
                        if item != None:
                            self.tool_tip = item.text()
                        else:
                            self.tool_tip = ""
                        return self.tool_tip
                    else:
                        self.col_width = self.col_width + current_col_width
            else:
                if self.mouse_y < self.row_height:
                    break
                else:
                    self.row_height = self.row_height + current_row_height

    def eventFilter(self, object, event):
        try:
            if event.type() == QEvent.ToolTip:
                self.setCursor(Qt.ArrowCursor)
                self.update_table_tooltip_signal.emit(event.pos())
                rect = QRect(self.mouse_x, self.mouse_y, 30, 10)
                self.setStyleSheet(
                    """QToolTip{border:10px;
                       border-top-left-radius:5px;
                       border-top-right-radius:5px;
                       border-bottom-left-radius:5px;
                       border-bottom-right-radius:5px;
                       background:#4F4F4F;
                       color:#FFFFFF;
                       font-size:18px;
                       font-family:"微软雅黑";
                    }""")
                QApplication.processEvents()
                QToolTip.showText(
                    QCursor.pos(), self.tool_tip, self, rect, 15000)
            return QWidget.eventFilter(self, object, event)
        except Exception as e:
            traceback.print_exc()


class my_SvgWidget(QSvgWidget):
    def __init__(self):
        super(my_SvgWidget, self).__init__()
        self.status = 0
        self.newPos = QPoint()

    def wheelEvent(self, e):
        if self.status == 1:
            e = e.angleDelta() / 8
            self.diff = 0.3
            if e.y() > 0:
                self.mywidth = self.width() + self.width() * self.diff
                self.myheight = self.height() + self.height() * self.diff
            else:
                self.mywidth = self.width() - self.width() * self.diff
                self.myheight = self.height() - self.height() * self.diff
            self.resize(int(self.mywidth), int(self.myheight))


class loginviewer(QMainWindow):
    def __init__(self, parent=None):
        QMainWindow.__init__(self, parent)
        self.ui = MainWindow()
        self.ui.show()


class SvgWindow(QScrollArea):
    def __init__(self):
        super(SvgWindow, self).__init__()
        self.svgwidget = my_SvgWidget()
        self.setWidget(self.svgwidget)
        self.svgwidget.setStyleSheet('''QWidget{background-color:#FFFFFF;}''')
        self.OK = False

    def setFileSize(self, filename):
        self.svgwidget.load(filename)
        myrender = self.svgwidget.renderer()
        self.svgwidget.resize(myrender.defaultSize())
        self.OK = True
        return myrender.defaultSize()

    def keyPressEvent(self, e) -> None:
        if e.modifiers() == Qt.ControlModifier:
            self.svgwidget.status = 1

    def keyReleaseEvent(self, a0: QtGui.QKeyEvent) -> None:
        self.svgwidget.status = 0

    def mousePressEvent(self, e) -> None:
        if self.OK:
            self.mousePressPos = e.pos()
            self.svgwidget.newPos.setX(self.horizontalScrollBar().value())
            self.svgwidget.newPos.setY(self.verticalScrollBar().value())
            e.accept()
        else:
            return

    def mouseMoveEvent(self, e) -> None:
        if self.OK:
            self.horizontalScrollBar().setValue(self.svgwidget.newPos.x() +
                                                (self.mousePressPos.x() - e.pos().x()))
            self.verticalScrollBar().setValue(self.svgwidget.newPos.y() +
                                              (self.mousePressPos.y() - e.pos().y()))
            self.horizontalScrollBar().update()
            self.verticalScrollBar().update()
            e.accept()
        else:
            return


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle(
            "svg viewer ('ctrl+the mouse wheel' will change the picture size)")
        self.resize(int(svgwidth)*10+60, int(svghight)*10-20)
        self.svgwindow = SvgWindow()
        self.opensvgfile()
        self.setCentralWidget(self.svgwindow)

    def opensvgfile(self):
        size = self.svgwindow.setFileSize("./candidate.svg")  # 这里需要传递一个文件名
        # self.resize(size)


class mytext(QLineEdit):
    def __int__(self):
        super(mytext, self).__init__()

    def dragEnterEvent(self, e):
        e.accept()

    def dropEvent(self, e):
        self.setText(os.path.abspath((e.mimeData().urls())
                     [0].toLocalFile()).replace("\\", "/"))


class LoadingButton(PushButton):
    @QtCore.pyqtSlot()
    def start(self):
        if hasattr(self, "_movie"):
            self._movie.start()

    @QtCore.pyqtSlot()
    def stop(self):
        if hasattr(self, "_movie"):
            self._movie.stop()
            self.setIcon(QtGui.QIcon())

    def setGif(self, filename):
        if not hasattr(self, "_movie"):
            self._movie = QtGui.QMovie(self)
            self._movie.setFileName(filename)
            self._movie.frameChanged.connect(self.on_frameChanged)
            if self._movie.loopCount() != -1:
                self._movie.finished.connect(self.start)
        self.stop()

    @QtCore.pyqtSlot(int)
    def on_frameChanged(self, frameNumber):
        self.setIcon(QtGui.QIcon(self._movie.currentPixmap()))


class loginform(QMainWindow):
    def __init__(self, parent=None):
        QMainWindow.__init__(self, parent)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    # app.setStyleSheet(qdarkgraystyle.load_stylesheet_pyqt5())
    qb = loginform()
    qb.show()
    sys.exit(app.exec_())
